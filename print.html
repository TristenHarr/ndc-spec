<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hasura Data Connectors  Developer&#x27;s Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><li class="part-title">API Specification</li><li class="chapter-item expanded "><a href="specification/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="specification/changelog.html"><strong aria-hidden="true">2.</strong> Changelog</a></li><li class="chapter-item expanded "><a href="specification/basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li class="chapter-item expanded "><a href="specification/versioning.html"><strong aria-hidden="true">4.</strong> Versioning</a></li><li class="chapter-item expanded "><a href="specification/error-handling.html"><strong aria-hidden="true">5.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="specification/health.html"><strong aria-hidden="true">6.</strong> Service Health</a></li><li class="chapter-item expanded "><a href="specification/metrics.html"><strong aria-hidden="true">7.</strong> Metrics</a></li><li class="chapter-item expanded "><a href="specification/telemetry.html"><strong aria-hidden="true">8.</strong> Telemetry</a></li><li class="chapter-item expanded "><a href="specification/capabilities.html"><strong aria-hidden="true">9.</strong> Capabilities</a></li><li class="chapter-item expanded "><a href="specification/types.html"><strong aria-hidden="true">10.</strong> Types</a></li><li class="chapter-item expanded "><a href="specification/schema/index.html"><strong aria-hidden="true">11.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/schema/scalar-types.html"><strong aria-hidden="true">11.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="specification/schema/object-types.html"><strong aria-hidden="true">11.2.</strong> Object Types</a></li><li class="chapter-item expanded "><a href="specification/schema/collections.html"><strong aria-hidden="true">11.3.</strong> Collections</a></li><li class="chapter-item expanded "><a href="specification/schema/functions.html"><strong aria-hidden="true">11.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="specification/schema/procedures.html"><strong aria-hidden="true">11.5.</strong> Procedures</a></li></ol></li><li class="chapter-item expanded "><a href="specification/queries/index.html"><strong aria-hidden="true">12.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="specification/queries/field-selection.html"><strong aria-hidden="true">12.1.</strong> Field Selection</a></li><li class="chapter-item expanded "><a href="specification/queries/filtering.html"><strong aria-hidden="true">12.2.</strong> Filtering</a></li><li class="chapter-item expanded "><a href="specification/queries/sorting.html"><strong aria-hidden="true">12.3.</strong> Sorting</a></li><li class="chapter-item expanded "><a href="specification/queries/pagination.html"><strong aria-hidden="true">12.4.</strong> Pagination</a></li><li class="chapter-item expanded "><a href="specification/queries/aggregates.html"><strong aria-hidden="true">12.5.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="specification/queries/arguments.html"><strong aria-hidden="true">12.6.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="specification/queries/relationships.html"><strong aria-hidden="true">12.7.</strong> Relationships</a></li><li class="chapter-item expanded "><a href="specification/queries/variables.html"><strong aria-hidden="true">12.8.</strong> Variables</a></li></ol></li><li class="chapter-item expanded "><a href="specification/mutations/index.html"><strong aria-hidden="true">13.</strong> Mutations</a></li><li class="chapter-item expanded "><a href="specification/explain.html"><strong aria-hidden="true">14.</strong> Explain</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial</li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">15.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tutorial/getting-started.html"><strong aria-hidden="true">16.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="tutorial/capabilities.html"><strong aria-hidden="true">17.</strong> Capabilities</a></li><li class="chapter-item expanded "><a href="tutorial/schema.html"><strong aria-hidden="true">18.</strong> Schema</a></li><li class="chapter-item expanded "><a href="tutorial/queries/index.html"><strong aria-hidden="true">19.</strong> Queries</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/queries/simple-queries.html"><strong aria-hidden="true">19.1.</strong> Simple Queries</a></li><li class="chapter-item expanded "><a href="tutorial/queries/relationships.html"><strong aria-hidden="true">19.2.</strong> Relationships</a></li><li class="chapter-item expanded "><a href="tutorial/queries/aggregates.html"><strong aria-hidden="true">19.3.</strong> Aggregates</a></li><li class="chapter-item expanded "><a href="tutorial/queries/arguments.html"><strong aria-hidden="true">19.4.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="tutorial/queries/variables.html"><strong aria-hidden="true">19.5.</strong> Variables</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/mutations/index.html"><strong aria-hidden="true">20.</strong> Mutations</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/types.html"><strong aria-hidden="true">21.</strong> Types</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Hasura Data Connectors  Developer&#x27;s Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Hasura data connectors allow you to extend the functionality of the Hasura server by providing web services which can resolve new sources of data. By following this specification, those sources of data can be added to your Hasura graph, and the usual Hasura features such as relationships and permissions will be supported for your data source.</p>
<p>This specification is designed to be as general as possible, supporting many different types of data source, while still being targeted enough to provide useful features with high performance guarantees. It is important to note that data connectors are designed for tabular data which supports efficient filtering and sorting. If you are able to model your data source given these constraints, then it will be a good fit for a data connector, but if not, you might like to consider a GraphQL remote source integration with Hasura instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-specification"><a class="header" href="#api-specification">API Specification</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Version</th></tr></thead><tbody>
<tr><td><code>0.1.0</code></td></tr>
</tbody></table>
</div>
<p>A data connector encapsulates a data source by implementing the protocol in this specification.</p>
<p>A data connector must implement several web service endpoints:</p>
<ul>
<li>A <strong>capabilities</strong> endpoint, which describes which features the data source is capable of implementing.</li>
<li>A <strong>schema</strong> endpoint, which describes the resources provided by the data source, and the shape of the data they contain.</li>
<li>A <strong>query</strong> endpoint, which reads data from one of the relations described by the schema endpoint.</li>
<li>A <strong>mutation</strong> endpoint, which modifies the data in one of the relations described by the schema endpoint.</li>
<li>An <strong>explain</strong> endpoint, which explains a query plan, without actually executing it.</li>
<li>A <strong>metrics</strong> endpoint, which exposes runtime metrics about the data connector.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h2 id="010"><a class="header" href="#010"><code>0.1.0</code></a></h2>
<h3 id="terminology"><a class="header" href="#terminology">Terminology</a></h3>
<p>Tables are now known as <em>collections</em>.</p>
<h3 id="collection-names"><a class="header" href="#collection-names">Collection Names</a></h3>
<p>Collection names are now single strings instead of arrays of strings. The array structure was previously used to represent qualification by a schema or database name, but the structure was not used anywhere on the client side, and had no semantic meaning. GDC now abstracts over these concepts, and expects relations to be named by strings.</p>
<h3 id="no-configuration"><a class="header" href="#no-configuration">No Configuration</a></h3>
<p>The configuration header convention was removed. Agents are now expected to manage their own configuration, and an agent URL fully represents that agent with its pre-specified configuration.</p>
<h3 id="no-database-concepts-in-gdc"><a class="header" href="#no-database-concepts-in-gdc">No Database Concepts in GDC</a></h3>
<p>GDC no longer sends any metadata to indicate database-specific concepts. For example, a Collection used to indicate whether it was a Collection or view. Such metadata would be passed back in the query IR, to help the agent disambiguate which database object to query. When we proposed adding functions, we would have had to add a new type to disambiguate nullary functions from collections, etc. Instead, we now expect agents to understand their own schema, and understand the query IR that they receive, as long as it is compatible with their GDC schema.</p>
<p>Column types are no longer sent in the query and mutation requests.</p>
<p>Tables, views and functions are unified under a single concept called &quot;collections&quot;. GDC does not care how queries and mutations on relations are implemented.</p>
<h3 id="collection-arguments"><a class="header" href="#collection-arguments">Collection Arguments</a></h3>
<p>Collection arguments were added to relations in order to support use cases like table-valued functions and certain REST endpoints. Relationships can determine collection arguments.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Collections which return a single column and a single row are also called &quot;functions&quot;, and identified separately in the schema response.</p>
<h3 id="field-arguments"><a class="header" href="#field-arguments">Field Arguments</a></h3>
<p>Field arguments were added to fields in order to support use cases like computed fields.</p>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p>The equality operator is now expected on every scalar type implicitly. </p>
<p><em>Note</em>: it was already implicitly supported by any agent advertising the <code>foreach</code> capability, which imposes column equality constraints in each row set fetched in a forall query.</p>
<p>The equality operator will have semantics assigned for the purposes of testing.</p>
<p>Scalars can define additional operators, whose semantics are opaque.</p>
<h3 id="procedures"><a class="header" href="#procedures">Procedures</a></h3>
<p>Proceduress were added to the list of available mutation operation types</p>
<h3 id="schema"><a class="header" href="#schema">Schema</a></h3>
<ul>
<li>Scalar types were moved to the schema endpoint</li>
<li>The <code>object_types</code> field was added to the schema endpoint</li>
</ul>
<h3 id="raw-queries"><a class="header" href="#raw-queries">Raw Queries</a></h3>
<p>The raw query endpoint was removed, since it cannot be given any useful semantics across all implementations.</p>
<h3 id="datasets"><a class="header" href="#datasets">Datasets</a></h3>
<p>The datasets endpoints were removed from the specification, because there was no way to usefully use it without prior knowledge of its implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Data connectors are implemented as HTTP services. To refer to a running data connector, it suffices to specify its base URL. All required endpoints are specified relative to this base URL.</p>
<p>All endpoints should accept JSON (in the case of POST request bodies) and return JSON using the <code>application/json</code> content type. The particular format of each JSON document will be specified for each endpoint.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="versioning"><a class="header" href="#versioning">Versioning</a></h1>
<p>This specification is versioned using semantic versioning, and a data connector claims compatibility with a <a href="https://semver.org">semantic version</a> range via its <a href="specification/capabilities.html">capabilities</a> endpoint.</p>
<p>Non-breaking changes to the specification may be achieved via the addition of new capabilities, which a connector will be assumed not to implement if the corresponding field is not present in its capabilities endpoint.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Data connectors should use standard HTTP error codes to signal error conditions back to the Hasura server. In particular, the following error codes should be used in the indicated scenarios:</p>
<div class="table-wrapper"><table><thead><tr><th>Response Code</th><th>Meaning</th><th>Used when</th></tr></thead><tbody>
<tr><td>200</td><td>OK</td><td>The request was handled successfully according to this specification .</td></tr>
<tr><td>400</td><td>Bad Request</td><td>The request did not match the data connector's expectation based on this specification.</td></tr>
<tr><td>403</td><td>Forbidden</td><td>The request could not be handled because a permission check failed - for example, a mutation might fail because a check constraint was not met.</td></tr>
<tr><td>409</td><td>Conflict</td><td>The request could not be handled because it would create a conflicting state for the data source - for example, a mutation might fail because a foreign key constraint was not met.</td></tr>
<tr><td>500</td><td>Internal Server Error</td><td>The request could not be handled because of an error on the server</td></tr>
<tr><td>501</td><td>Not Supported</td><td>The request could not be handled because it relies on an unsupported <a href="specification/capabilities.html">capability</a>. <em>Note</em>: this ought to indicate an error on the <em>caller</em> side, since the caller should not generate requests which are incompatible with the indicated capabilities.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="service-health"><a class="header" href="#service-health">Service Health</a></h1>
<p>Data connectors should provide a <strong>health endpoint</strong> which can be used to indicate service health and readiness to any client applications.</p>
<h2 id="request"><a class="header" href="#request">Request</a></h2>
<pre><code>GET /healthz
</code></pre>
<h2 id="response"><a class="header" href="#response">Response</a></h2>
<p>If the data connector is available and ready to accept requests, then the health endpoint should return status code <code>204 No Content</code>.</p>
<p>Otherwise, it should ideally return a status code <code>503 Service Unavailable</code>, or some other appropriate HTTP error code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p>Data connectors should provide a <strong>metrics endpoint</strong> which reports relevant metrics in a textual format. Data connectors can report any metrics which are deemed relevant, or none at all, with the exception of any reserved keys.</p>
<h2 id="request-1"><a class="header" href="#request-1">Request</a></h2>
<pre><code>GET /metrics
</code></pre>
<h2 id="response-1"><a class="header" href="#response-1">Response</a></h2>
<p>The metrics endpoint should return a content type of <code>text/plain</code>, and return any metrics in the <a href="https://prometheus.io/docs/instrumenting/exposition_formats/#text-based-format">Prometheus textual format</a>.</p>
<h3 id="reserved-keys"><a class="header" href="#reserved-keys">Reserved keys</a></h3>
<p>Metric names prefixed with <code>hasura_</code> are reserved for future use, and should not be included in the response.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code># HELP query_total The number of /query requests served
# TYPE query_total counter
query_total 10000 1685405427000
# HELP mutation_total The number of /mutation requests served
# TYPE mutation_total counter
mutation_total 5000 1685405427000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="telemetry"><a class="header" href="#telemetry">Telemetry</a></h1>
<p>Hasura uses OpenTelemetry to coordinate the collection of traces and metrics with data connectors.</p>
<h2 id="trace-collection"><a class="header" href="#trace-collection">Trace Collection</a></h2>
<p>Trace collection is out of the scope of this specification currently. This may change in a future revision.</p>
<h2 id="trace-propagation"><a class="header" href="#trace-propagation">Trace Propagation</a></h2>
<p>Hasura uses the <a href="https://www.w3.org/TR/trace-context/">W3C TraceContext specification</a> to implement trace propagation. Data connectors should propagate tracing headers in this format to any downstream services.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capabilities"><a class="header" href="#capabilities">Capabilities</a></h1>
<p>The capabilities endpoint provides metadata about the features which the data connector (and data source) support.</p>
<h2 id="request-2"><a class="header" href="#request-2">Request</a></h2>
<pre><code>GET /capabilities
</code></pre>
<h2 id="response-2"><a class="header" href="#response-2">Response</a></h2>
<p>See <a href="specification/../reference/types.html#capabilitiesresponse"><code>CapabilitiesResponse</code></a></p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-json">{
  &quot;versions&quot;: &quot;^0.1.0&quot;,
  &quot;capabilities&quot;: {
    &quot;query&quot;: {
      &quot;relation_comparisons&quot;: {},
      &quot;order_by_aggregate&quot;: {},
      &quot;foreach&quot;: {}
    },
    &quot;mutations&quot;: {
      &quot;nested_inserts&quot;: {},
      &quot;returning&quot;: {}
    },
    &quot;relationships&quot;: {}
  }
}
</code></pre>
<h2 id="response-fields"><a class="header" href="#response-fields">Response Fields</a></h2>
<p><em>TODO</em>: nested_inserts and relation_comparisons seem like special cases of relationships</p>
<p><em>TODO</em>: the code doesn't actually follow this response format right now</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>versions</code></td><td>A <a href="https://semver.org">semantic versioning</a> range of API versions which the data connector claims to implement</td></tr>
<tr><td><code>capabilities.query.foreach</code></td><td>Whether the data connector supports <a href="specification/queries/foreach.html"><code>foreach</code> queries</a></td></tr>
<tr><td><code>capabilities.query.relation_comparisons</code></td><td>Whether comparisons can include columns reachable via <a href="specification/queries/relationships.html">relationships</a></td></tr>
<tr><td><code>capabilities.query.order_by_aggregate</code></td><td>Whether order by clauses can include aggregates</td></tr>
<tr><td><code>capabilities.mutations.nested_inserts</code></td><td>Whether nested insert mutations are supported</td></tr>
<tr><td><code>capabilities.mutations.returning</code></td><td>Whether mutations return rows of modified data</td></tr>
<tr><td><code>capabilities.explain</code></td><td>Whether the data connector is capable of describing query plans</td></tr>
<tr><td><code>capabilities.relationships</code></td><td>Whether the data connector supports <a href="specification/queries/relationships.html">relationships</a></td></tr>
</tbody></table>
</div>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li>Type <a href="specification/../reference/types.html#capabilities"><code>Capabilities</code></a></li>
<li>Type <a href="specification/../reference/types.html#capabilitiesresponse"><code>CapabilitiesResponse</code></a></li>
<li>Type <a href="specification/../reference/types.html#mutationcapabilities"><code>MutationCapabilities</code></a></li>
<li>Type <a href="specification/../reference/types.html#querycapabilities"><code>QueryCapabilities</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Several definitions in this specification make mention of <em>types</em>. Types are used to categorize the sorts of data returned and accepted by a data connector.</p>
<p>Scalar and named object types are defined in the <a href="specification/./schema/README.html">schema response
</a>, and referred to by name at the point of use.</p>
<p>Array types and nullable types are constructed at the point of use.</p>
<h2 id="named-types"><a class="header" href="#named-types">Named Types</a></h2>
<p>To refer to a named (scalar or object) type, use the type <code>named</code>, and provide the name:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;named&quot;,
  &quot;name&quot;: &quot;String&quot;
}
</code></pre>
<h2 id="array-types"><a class="header" href="#array-types">Array Types</a></h2>
<p>To refer to an array type, use the type <code>array</code>, and refer to the type of the elements of the array in the <code>element_type</code> field:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;array&quot;,
  &quot;element_type&quot;: {
    &quot;type&quot;: &quot;named&quot;,
    &quot;name&quot;: &quot;String&quot;
  }
}
</code></pre>
<h2 id="nullable-types"><a class="header" href="#nullable-types">Nullable Types</a></h2>
<p>To refer to a nullable type, use the type <code>nullable</code>, and refer to the type of the underlying (non-null) inhabitants in the <code>underlying_type</code> field:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;nullable&quot;,
  &quot;underlying_type&quot;: {
    &quot;type&quot;: &quot;named&quot;,
    &quot;name&quot;: &quot;String&quot;
  }
}
</code></pre>
<p>Nullable and array types can be nested. For example, to refer to a nullable array of nullable strings:</p>
<pre><code class="language-json">{
  &quot;type&quot;: &quot;nullable&quot;,
  &quot;underlying_type&quot;: {
    &quot;type&quot;: &quot;array&quot;,
    &quot;element_type&quot;: {
      &quot;type&quot;: &quot;nullable&quot;,
      &quot;underlying_type&quot;: {
        &quot;type&quot;: &quot;named&quot;,
        &quot;name&quot;: &quot;String&quot;
      }
    }
  }
}
</code></pre>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See also</a></h2>
<ul>
<li>Type <a href="specification/../reference/types.html#type"><code>Type</code>
</a></li>
<li><a href="specification/./schema/scalar-types.html">Scalar types
</a></li>
<li><a href="specification/./schema/object-types.html">Object types
</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema-1"><a class="header" href="#schema-1">Schema</a></h1>
<p>The schema endpoint defines any types used by the data connector, and describes the collections and their columns, functions, and any procedures.</p>
<p>The schema endpoint is used to specify the behavior of a data connector, so that it can be tested, verified, and used by tools such as code generators. It is primarily provided by data connector implementors as a development and specification tool, and it is not expected to be used at &quot;runtime&quot;, in the same sense that the <code>/query</code> and <code>/mutation</code> endpoints would be.</p>
<h2 id="request-3"><a class="header" href="#request-3">Request</a></h2>
<pre><code>GET /schema
</code></pre>
<h2 id="response-3"><a class="header" href="#response-3">Response</a></h2>
<p>See <a href="specification/schema/../../reference/types.html#schemaresponse"><code>SchemaResponse</code></a></p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-json">{
  &quot;scalar_types&quot;: {
    &quot;Int&quot;: {
      &quot;aggregate_functions&quot;: {
        &quot;max&quot;: {
          &quot;result_type&quot;: {
            &quot;type&quot;: &quot;nullable&quot;,
            &quot;underlying_type&quot;: {
              &quot;type&quot;: &quot;named&quot;,
              &quot;name&quot;: &quot;Int&quot;
            }
          }
        },
        &quot;min&quot;: {
          &quot;result_type&quot;: {
            &quot;type&quot;: &quot;nullable&quot;,
            &quot;underlying_type&quot;: {
              &quot;type&quot;: &quot;named&quot;,
              &quot;name&quot;: &quot;Int&quot;
            }
          }
        }
      },
      &quot;comparison_operators&quot;: {},
      &quot;update_operators&quot;: {}
    },
    &quot;String&quot;: {
      &quot;aggregate_functions&quot;: {},
      &quot;comparison_operators&quot;: {
        &quot;like&quot;: {
          &quot;argument_type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;String&quot;
          }
        }
      },
      &quot;update_operators&quot;: {}
    }
  },
  &quot;object_types&quot;: {
    &quot;article&quot;: {
      &quot;description&quot;: &quot;An article&quot;,
      &quot;fields&quot;: {
        &quot;author_id&quot;: {
          &quot;description&quot;: &quot;The article's author ID&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;Int&quot;
          }
        },
        &quot;id&quot;: {
          &quot;description&quot;: &quot;The article's primary key&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;Int&quot;
          }
        },
        &quot;title&quot;: {
          &quot;description&quot;: &quot;The article's title&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;String&quot;
          }
        }
      }
    },
    &quot;author&quot;: {
      &quot;description&quot;: &quot;An author&quot;,
      &quot;fields&quot;: {
        &quot;first_name&quot;: {
          &quot;description&quot;: &quot;The author's first name&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;String&quot;
          }
        },
        &quot;id&quot;: {
          &quot;description&quot;: &quot;The author's primary key&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;Int&quot;
          }
        },
        &quot;last_name&quot;: {
          &quot;description&quot;: &quot;The author's last name&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;String&quot;
          }
        }
      }
    }
  },
  &quot;collections&quot;: [
    {
      &quot;name&quot;: &quot;articles&quot;,
      &quot;description&quot;: &quot;A collection of articles&quot;,
      &quot;arguments&quot;: {},
      &quot;type&quot;: &quot;article&quot;,
      &quot;deletable&quot;: false,
      &quot;uniqueness_constraints&quot;: {
        &quot;ArticleByID&quot;: {
          &quot;unique_columns&quot;: [
            &quot;id&quot;
          ]
        }
      },
      &quot;foreign_keys&quot;: {}
    },
    {
      &quot;name&quot;: &quot;authors&quot;,
      &quot;description&quot;: &quot;A collection of authors&quot;,
      &quot;arguments&quot;: {},
      &quot;type&quot;: &quot;author&quot;,
      &quot;deletable&quot;: false,
      &quot;uniqueness_constraints&quot;: {
        &quot;AuthorByID&quot;: {
          &quot;unique_columns&quot;: [
            &quot;id&quot;
          ]
        }
      },
      &quot;foreign_keys&quot;: {}
    },
    {
      &quot;name&quot;: &quot;articles_by_author&quot;,
      &quot;description&quot;: &quot;Articles parameterized by author&quot;,
      &quot;arguments&quot;: {
        &quot;author_id&quot;: {
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;Int&quot;
          }
        }
      },
      &quot;type&quot;: &quot;article&quot;,
      &quot;deletable&quot;: false,
      &quot;uniqueness_constraints&quot;: {},
      &quot;foreign_keys&quot;: {}
    }
  ],
  &quot;functions&quot;: [
    {
      &quot;name&quot;: &quot;latest_article_id&quot;,
      &quot;description&quot;: &quot;Get the ID of the most recent article&quot;,
      &quot;arguments&quot;: {},
      &quot;result_type&quot;: {
        &quot;type&quot;: &quot;nullable&quot;,
        &quot;underlying_type&quot;: {
          &quot;type&quot;: &quot;named&quot;,
          &quot;name&quot;: &quot;Int&quot;
        }
      }
    }
  ],
  &quot;procedures&quot;: [
    {
      &quot;name&quot;: &quot;upsert_article&quot;,
      &quot;description&quot;: &quot;Insert or update an article&quot;,
      &quot;arguments&quot;: {
        &quot;article&quot;: {
          &quot;description&quot;: &quot;The article to insert or update&quot;,
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;article&quot;
          }
        }
      },
      &quot;result_type&quot;: {
        &quot;type&quot;: &quot;nullable&quot;,
        &quot;underlying_type&quot;: {
          &quot;type&quot;: &quot;named&quot;,
          &quot;name&quot;: &quot;article&quot;
        }
      }
    }
  ]
}
</code></pre>
<h2 id="response-fields-1"><a class="header" href="#response-fields-1">Response Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>scalar_types</code></td><td><a href="specification/schema/scalar-types.html">Scalar Types</a></td></tr>
<tr><td><code>object_types</code></td><td><a href="specification/schema/object-types.html">Object Types</a></td></tr>
<tr><td><code>collections</code></td><td><a href="specification/schema/collections.html">Collection</a></td></tr>
<tr><td><code>functions</code></td><td><a href="specification/schema/Functions.html">Functions</a></td></tr>
<tr><td><code>procedures</code></td><td><a href="specification/schema/procedures.html">Procedures</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h1>
<p>The schema should describe any irreducible <em>scalar types</em>. Scalar types can be used as the types of columns, or in general as the types of object fields.</p>
<p>Scalar types define several types of operations, which extend the capabilities of the query and mutation APIs: <em>comparison operators</em>, <em>aggregation functions</em>, and <em>update operators</em>.</p>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<p>Comparison operators extend the query AST with the ability to express new binary comparison expressions in the predicate.</p>
<p><em>Note</em>: data connectors are required to implement the <em>equality</em> operator for all scalar types, and that operator is distinguished in the query AST. There is no need to define the equality operator as a comparison operator.</p>
<p>For example, a data connector might augment a <code>String</code> scalar type with a <code>LIKE</code> operator which tests for a fuzzy match based on a regular expression.</p>
<p>A comparison operator is defined by its <em>argument type</em> - that is, the type of the right hand side of the binary operator it represents.</p>
<p>To define a comparison operator, add a <a href="specification/schema/../../reference/types.html#comparisonoperatordefinition"><code>ComparisonOperatorDefinition</code></a> to the <code>comparison_operators</code> field of the schema response.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;scalar_types&quot;: {
    &quot;String&quot;: {
      &quot;aggregate_functions&quot;: {},
      &quot;comparison_operators&quot;: {
        &quot;like&quot;: {
          &quot;argument_type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;String&quot;
          }
        }
      },
      &quot;update_operators&quot;: {}
    }
  },
  ...
}
</code></pre>
<h2 id="aggregation-functions"><a class="header" href="#aggregation-functions">Aggregation Functions</a></h2>
<p>Aggregation functions extend the query AST with the ability to express new aggregates within the <code>aggregates</code> portion of a query.</p>
<p><em>Note</em>: data connectors are required to implement the <em>count</em> and <em>count-distinct</em> aggregations for columns of all scalar types, and those operator is distinguished in the query AST. There is no need to define these aggregates as aggregation functions.</p>
<p>For example, a data connector might augment a <code>Float</code> scalar type with a <code>SUM</code> function which aggregates a sum of a collection of floating-point numbers.</p>
<p>An aggregation function is defined by its <em>result type</em> - that is, the type of the aggregated data.</p>
<p>To define an aggregation function, add a <a href="specification/schema/../../reference/types.html#aggregatefunctiondefinition"><code>AggregateFunctionDefinition</code></a> to the <code>aggregate_functions</code> field of the schema response.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;scalar_types&quot;: {
    &quot;Float&quot;: {
      &quot;aggregate_functions&quot;: {
        &quot;sum&quot;: {
          &quot;result_type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;Float&quot;
          }
        }
      },
      &quot;comparison_operators&quot;: {},
      &quot;update_operators&quot;: {}
    }
  },
  ...
}
</code></pre>
<h2 id="update-operators"><a class="header" href="#update-operators">Update Operators</a></h2>
<p>Update operators extend the mutation AST with the ability to express new kinds of updates on individual columns with those types.</p>
<p><em>Note</em>: data connectors are required to implement the <em>set</em> update operator for columns of all scalar types, and that operator is distinguished in the mutation AST. There is no need to define the set operator as an update operator.</p>
<p>For example, a data connector might augment an <code>Int</code> scalar type with an <code>INC</code> operator which increments the value of an integer-valued column.</p>
<p>An update operator is defined by its <em>argument type</em> - that is, the type of the right hand side of the binary operator it represents.</p>
<p>To define an update operator, add a <a href="specification/schema/../../reference/types.html#updateoperatordefinition"><code>UpdateOperatorDefinition</code></a> to the <code>update_operators</code> field of the schema response.</p>
<p>For example:</p>
<pre><code class="language-json">{
  &quot;scalar_types&quot;: {
    &quot;Int&quot;: {
      &quot;aggregate_functions&quot;: {},
      &quot;comparison_operators&quot;: {},
      &quot;update_operators&quot;: {
        &quot;inc&quot;: {
          &quot;argument_type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;Int&quot;
          }
        }
      }
    }
  },
  ...
}
</code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#scalartype"><code>ScalarType</code></a></li>
<li><a href="specification/schema/../queries/filtering.html"><code>Filtering</code></a></li>
<li><a href="specification/schema/../queries/aggregates.html"><code>Aggregates</code></a></li>
<li><a href="specification/schema/../mutations/update.html"><code>Update Mutations</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-types"><a class="header" href="#object-types">Object Types</a></h1>
<p>The schema should define any named <em>object types</em> which will be used as the types of <a href="specification/schema/./collections.html">collection</a> row sets, or <a href="specification/schema/./procedures.html">procedure</a> inputs or outputs.</p>
<p>An object type consists of a name and a collection of named fields. Each field is defined by its <a href="specification/schema/../types.html">type</a>, and any <a href="specification/schema/../queries/arguments.html">arguments</a>.</p>
<p><em>Note</em>: field arguments are only used in a query context, and ignored when an object type is used in other contexts (such as the input type of a <em>procedure</em>).</p>
<p>To define an object type, add an <a href="specification/schema/../../reference/types.html#objecttype"><code>ObjectType</code>
</a> to the <code>object_types</code> field of the schema response.</p>
<h2 id="example-3"><a class="header" href="#example-3">Example</a></h2>
<pre><code class="language-json">{
  &quot;object_types&quot;: {
    &quot;coords&quot;: {
      &quot;description&quot;: &quot;Latitude and longitude&quot;,
      &quot;fields&quot;: {
        &quot;latitude&quot;: {
          &quot;description&quot;: &quot;Latitude in degrees north of the equator&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;Float&quot;
          }
        },
        &quot;longitude&quot;: {
          &quot;description&quot;: &quot;Longitude in degrees east of the Greenwich meridian&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;Float&quot;
          }
        }
      }
    },
    ...
  },
  ...
}
</code></pre>
<h2 id="extended-example"><a class="header" href="#extended-example">Extended Example</a></h2>
<p>Object types can refer to other object types in the types of their fields, and make use of other <a href="specification/schema/../types.html">type structure</a> such as array types and nullable types.</p>
<p>In the context of array types, it can be useful to use <a href="specification/schema/../queries/arguments.html">arguments</a> on fields to allow the caller to customize the response.</p>
<p>For example, here we define a type <code>widget</code>, and a second type which contains a <code>widgets</code> field, parameterized by a <code>limit</code> argument:</p>
<pre><code class="language-json">{
  &quot;object_types&quot;: {
    &quot;widget&quot;: {
      &quot;description&quot;: &quot;Description of a widget&quot;,
      &quot;fields&quot;: {
        &quot;id&quot;: {
          &quot;description&quot;: &quot;Primary key&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;ID&quot;
          }
        },
        &quot;name&quot;: {
          &quot;description&quot;: &quot;Name of this widget&quot;,
          &quot;arguments&quot;: {},
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;String&quot;
          }
        }
      }
    },
    &quot;inventory&quot;: {
      &quot;description&quot;: &quot;The items in stock&quot;,
      &quot;fields&quot;: {
        &quot;widgets&quot;: {
          &quot;description&quot;: &quot;Those widgets currently in stock&quot;,
          &quot;arguments&quot;: {
            &quot;limit&quot;: {
              &quot;description&quot;: &quot;The maximum number of widgets to fetch&quot;,
              &quot;argument_type&quot;: {
                &quot;type&quot;: &quot;named&quot;,
                &quot;name&quot;: &quot;Int&quot;
              }
            }
          },
          &quot;type&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;element_type&quot;: {
              &quot;type&quot;: &quot;named&quot;,
              &quot;name&quot;: &quot;widget&quot;
            }
          }
        }
      }
    }
  },
  ...
}
</code></pre>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#objecttype"><code>ObjectType</code></a></li>
<li>Type <a href="specification/schema/../../reference/types.html#objectfield"><code>ObjectField</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>The schema should define the metadata for any <em>collections</em> which can be queried using the query endpoint, or mutated using the mutation endpoint.</p>
<p>Each collection is defined by its name, any collection <a href="specification/schema/../queries/arguments.html">arguments</a>, the <a href="specification/schema/./object-types.html">object type</a> of its rows, and some additional metadata related to permissions and constraints.</p>
<p>To describe a collection, add a <a href="specification/schema/../../reference/types.html#collectioninfo"><code>CollectionInfo</code></a> structure to the <code>collections</code> field of the schema response.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>The <code>type</code> field should name an object type which is defined in the schema response.</li>
</ul>
<h2 id="example-4"><a class="header" href="#example-4">Example</a></h2>
<pre><code class="language-json">{
  &quot;collections&quot;: [
    {
      &quot;name&quot;: &quot;articles&quot;,
      &quot;description&quot;: &quot;A collection of articles&quot;,
      &quot;arguments&quot;: {},
      &quot;type&quot;: &quot;article&quot;,
      &quot;deletable&quot;: false,
      &quot;uniqueness_constraints&quot;: {
        &quot;ArticleByID&quot;: {
          &quot;unique_columns&quot;: [
            &quot;id&quot;
          ]
        }
      },
      &quot;foreign_keys&quot;: {}
    },
    {
      &quot;name&quot;: &quot;authors&quot;,
      &quot;description&quot;: &quot;A collection of authors&quot;,
      &quot;arguments&quot;: {},
      &quot;type&quot;: &quot;author&quot;,
      &quot;deletable&quot;: false,
      &quot;uniqueness_constraints&quot;: {
        &quot;AuthorByID&quot;: {
          &quot;unique_columns&quot;: [
            &quot;id&quot;
          ]
        }
      },
      &quot;foreign_keys&quot;: {}
    }
  ],
  ...
}
</code></pre>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#collectioninfo"><code>CollectionInfo</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Functions are a special case of <a href="specification/schema/./collections.html">collections</a>, which are identified separately in the schema for convenience. </p>
<p>A function is a collection which returns a single row and a single column, named <code>__value</code>. Like collections, functions can have arguments. Unlike collections, functions cannot be used by the mutations endpoint, do not describe constraints, and only provide a type for the <code>__value</code> column, not the name of an object type.</p>
<p><em>Note</em>: even though a function acts like a collection returning a row type with a single column, there is no need to define and name such a type in the <code>object_types</code> section of the schema response.</p>
<p>To describe a function, add a <a href="specification/schema/../../reference/types.html#FunctionInfo"><code>FunctionInfo</code></a> structure to the <code>functions</code> field of the schema response.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><code class="language-json">{
  &quot;functions&quot;: [
    {
      &quot;name&quot;: &quot;latest_article_id&quot;,
      &quot;description&quot;: &quot;Get the ID of the most recent article&quot;,
      &quot;arguments&quot;: {},
      &quot;result_type&quot;: {
        &quot;type&quot;: &quot;nullable&quot;,
        &quot;underlying_type&quot;: {
          &quot;type&quot;: &quot;named&quot;,
          &quot;name&quot;: &quot;Int&quot;
        }
      }
    }
  ],
  ...
}
</code></pre>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#FunctionInfo"><code>FunctionInfo</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="procedures-1"><a class="header" href="#procedures-1">Procedures</a></h1>
<p>The schema should define metadata for each <em>procedure</em> which the data connector implements.</p>
<p>Each procedure is defined by its name, any arguments types and a result type.</p>
<p>To describe a procedure, add a <a href="specification/schema/../../reference/types.html#procedureinfo"><code>ProcedureInfo</code></a> structure to the <code>procedure</code> field of the schema response.</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><code class="language-json">{
  &quot;procedures&quot;: [
    {
      &quot;name&quot;: &quot;upsert_article&quot;,
      &quot;description&quot;: &quot;Insert or update an article&quot;,
      &quot;arguments&quot;: {
        &quot;article&quot;: {
          &quot;description&quot;: &quot;The article to insert or update&quot;,
          &quot;type&quot;: {
            &quot;type&quot;: &quot;named&quot;,
            &quot;name&quot;: &quot;article&quot;
          }
        }
      },
      &quot;result_type&quot;: {
        &quot;type&quot;: &quot;named&quot;,
        &quot;name&quot;: &quot;article&quot;
      }
    }
  ],
  ...
}
</code></pre>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See also</a></h2>
<ul>
<li>Type <a href="specification/schema/../../reference/types.html#procedureinfo"><code>ProcedureInfo</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries"><a class="header" href="#queries">Queries</a></h1>
<p>The query endpoint accepts a query request, containing expressions to be evaluated in the context the data source, and returns a response consisting of relevant rows of data.</p>
<p>The structure and requirements for specific fields listed below will be covered in subsequent chapters.</p>
<h2 id="request-4"><a class="header" href="#request-4">Request</a></h2>
<pre><code>POST /query
</code></pre>
<h2 id="request-5"><a class="header" href="#request-5">Request</a></h2>
<p>See <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a></p>
<h2 id="request-fields"><a class="header" href="#request-fields">Request Fields</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>collection</code></td><td>The name of a collection to query</td></tr>
<tr><td><code>query</code></td><td>The query syntax tree</td></tr>
<tr><td><code>arguments</code></td><td>Values to be provided to any top-level <a href="specification/queries/./arguments.html">collection arguments</a></td></tr>
<tr><td><code>collection_relationships</code></td><td>Any <a href="specification/queries/./relationships.html">relationships</a> between collections involved in the query request</td></tr>
<tr><td><code>variables</code></td><td>One set of <a href="specification/queries/./variables.html">named variables</a> for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned.</td></tr>
</tbody></table>
</div>
<h2 id="response-4"><a class="header" href="#response-4">Response</a></h2>
<p>See <a href="specification/queries/../../reference/types.html#queryresponse"><code>QueryResponse</code></a></p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li>If the request specifies <code>variables</code>, then the response must contain one <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a> for each collection of variables provided. If not, the data connector should respond as if <code>variables</code> were set to a single empty collection of variables: <code>[{}]</code>.</li>
<li>If the request specifies <code>fields</code>, then the response must contain <code>rows</code> according to the <a href="specification/queries/../schema/README.html">schema</a> advertised for the requested <code>collection</code>.</li>
<li>If the request specifies <code>aggregates</code> then the response must contain <code>aggregates</code>, with one response key per requested aggregate, using the same keys. See <a href="specification/queries/./aggregates.html">aggregates</a>.</li>
<li>If the request specifies <code>arguments</code>, then the implementation must validate the provided arguments against the types specified by the collection's <a href="specification/queries/../schema/README.html">schema</a>. See <a href="specification/queries/./arguments.html">arguments</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-selection"><a class="header" href="#field-selection">Field Selection</a></h1>
<p>A <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> can specify which fields to fetch. The available fields are either</p>
<ul>
<li>the columns on the selected collection (i.e. those advertised in the corresponding <a href="specification/queries/../../reference/types.html#collectioninfo"><code>CollectionInfo</code></a> structure in the <a href="specification/queries/../schema/collections.html">schema response</a>), or</li>
<li>fields from <a href="specification/queries/./relationships.html">related collections</a></li>
</ul>
<p>The requested fields are specified as a collection of <a href="specification/queries/../../reference/types.html#field"><code>Field</code></a> structures in the <code>field</code> property on the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a>.</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<p>Here is an example of a query which selects some columns from the <code>articles</code> collection of the reference data connector:</p>
<pre><code class="language-json">{
    &quot;collection&quot;: &quot;articles&quot;,
    &quot;arguments&quot;: {},
    &quot;query&quot;: {
        &quot;fields&quot;: {
            &quot;id&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;id&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;title&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;title&quot;,
                &quot;arguments&quot;: {}
            }
        }
    },
    &quot;collection_relationships&quot;: {}
}
</code></pre>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<ul>
<li>If the <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a> contains a <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> which specifies <code>fields</code>, then each <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a> in the response should contain the <code>rows</code> property, and each row should contain all of the requested fields.</li>
</ul>
<h2 id="see-also-7"><a class="header" href="#see-also-7">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#rowfieldvalue"><code>RowFieldValue</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filtering"><a class="header" href="#filtering">Filtering</a></h1>
<p>A <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> can specify a predicate expression which should be used to filter rows in the response.</p>
<p>A predicate expression can be one of</p>
<ul>
<li>An application of a <em>comparison operator</em> to a column and a value, or</li>
<li>An <code>EXISTS</code> expression, or</li>
<li>A <em>conjunction</em> of other expressions, or</li>
<li>A <em>disjunction</em> of other expressions, or</li>
<li>A <em>negation</em> of another expression</li>
</ul>
<p>The predicate expression is specified in the <code>predicate</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object.</p>
<h2 id="comparison-operators-1"><a class="header" href="#comparison-operators-1">Comparison Operators</a></h2>
<h3 id="unary-operators"><a class="header" href="#unary-operators">Unary Operators</a></h3>
<p>Unary comparison operators are denoted by expressions with a <code>type</code> field of <code>unary_comparison_operator</code>.</p>
<p>The only supported unary operator currently is <code>is_null</code>, which return <code>true</code> when a column value is <code>null</code>:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;unary_comparison_operator&quot;,
    &quot;operator&quot;: &quot;is_null&quot;,
    &quot;column&quot;: {
        &quot;name&quot;: &quot;title&quot;
    }
}
</code></pre>
<h3 id="binary-operators"><a class="header" href="#binary-operators">Binary Operators</a></h3>
<p>Binary comparison operators are denoted by expressions with a <code>type</code> field of <code>binary_comparison_operator</code>. </p>
<p>The set of available operators depends on the type of the column involved in the expression. The <code>equal</code> operator should be implemented for all types of columns. </p>
<p>See type <a href="specification/queries/../../reference/types.html#binarycomparisonoperator"><code>BinaryComparisonOperator</code></a>.</p>
<h4 id="equals"><a class="header" href="#equals"><code>equals</code></a></h4>
<p><code>equals</code> tests if a column value is equal to a scalar value, another column value, or a variable.</p>
<p>See type <a href="specification/queries/../../reference/types.html#comparisonvalue"><code>ComparisonValue</code></a> for the valid inhabitants of the <code>value</code> field.</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;binary_comparison_operator&quot;,
    &quot;operator&quot;: {
        &quot;type&quot;: &quot;equal&quot;
    },
    &quot;column&quot;: {
        &quot;name&quot;: &quot;title&quot;
    },
    &quot;value&quot;: {
        &quot;type&quot;: &quot;scalar&quot;,
        &quot;value&quot;: &quot;The Next 700 Programming Languages&quot;
    }
}
</code></pre>
<h3 id="custom-binary-comparison-operators"><a class="header" href="#custom-binary-comparison-operators">Custom Binary Comparison Operators</a></h3>
<p>Data connectors can also extend the expression grammar by defining comparison operators on each <a href="specification/queries/../schema/scalar-types.html">scalar type</a> in the schema response.</p>
<p>For example, here is an expression which uses a custom <code>like</code> operator provided on the <code>String</code> type in the reference implementation:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;binary_comparison_operator&quot;,
    &quot;operator&quot;: {
        &quot;type&quot;: &quot;other&quot;,
        &quot;name&quot;: &quot;like&quot;
    },
    &quot;column&quot;: {
        &quot;name&quot;: &quot;title&quot;
    },
    &quot;value&quot;: {
        &quot;type&quot;: &quot;scalar&quot;,
        &quot;value&quot;: &quot;^.*Functional Programming.*$&quot;
    }
}
</code></pre>
<h3 id="binary-array-valued-comparison-operators"><a class="header" href="#binary-array-valued-comparison-operators">Binary Array-Valued Comparison Operators</a></h3>
<p>Binary comparison operators are denoted by expressions with a <code>type</code> field of <code>binary_array_comparison_operator</code>. </p>
<h4 id="in"><a class="header" href="#in"><code>in</code></a></h4>
<p><code>in</code> tests if a column value is a member of an array of values, each of which can be a scalar value, another column value, or a variable.</p>
<p>See type <a href="specification/queries/../../reference/types.html#comparisonvalue"><code>ComparisonValue</code></a> for the valid inhabitants of the <code>value</code> field.</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;binary_array_comparison_operator&quot;,
    &quot;operator&quot;: &quot;in&quot;,
    &quot;column&quot;: {
        &quot;name&quot;: &quot;id&quot;
    },
    &quot;values&quot;: [
        {
            &quot;type&quot;: &quot;scalar&quot;,
            &quot;value&quot;: &quot;1&quot;
        },
        {
            &quot;type&quot;: &quot;scalar&quot;,
            &quot;value&quot;: &quot;2&quot;
        }
    ]
}
</code></pre>
<h2 id="exists-expressions"><a class="header" href="#exists-expressions"><code>EXISTS</code> expressions</a></h2>
<p>An <code>EXISTS</code> expression tests whether a row exists in some possibly-related collection, and is denoted by an expression with a <code>type</code> field of <code>exists</code>.</p>
<p><code>EXISTS</code> expressions can query related or unrelated collections. </p>
<h3 id="related-collections"><a class="header" href="#related-collections">Related Collections</a></h3>
<p>Related collections are related to the original collection by a relationship in the <code>collection_relationships</code> field of the top-level <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a>.</p>
<p>For example, this query fetches authors who have written articles whose titles contain the string <code>&quot;Functional&quot;</code>:</p>
<pre><code class="language-json">{
    &quot;collection&quot;: &quot;authors&quot;,
    &quot;arguments&quot;: {},
    &quot;query&quot;: {
        &quot;fields&quot;: {
            &quot;first_name&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;first_name&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;last_name&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;last_name&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;articles&quot;: {
                &quot;type&quot;: &quot;relationship&quot;,
                &quot;arguments&quot;: {},
                &quot;relationship&quot;: &quot;author_articles&quot;,
                &quot;query&quot;: {
                    &quot;fields&quot;: {
                        &quot;id&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;column&quot;: &quot;id&quot;,
                            &quot;arguments&quot;: {}
                        },
                        &quot;title&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;column&quot;: &quot;title&quot;,
                            &quot;arguments&quot;: {}
                        }
                    }
                }
            }
        },
        &quot;where&quot;: {
            &quot;type&quot;: &quot;exists&quot;,
            &quot;in_collection&quot;: {
                &quot;type&quot;: &quot;related&quot;,
                &quot;arguments&quot;: {},
                &quot;relationship&quot;: &quot;author_articles&quot;
            },
            &quot;where&quot;: {
                &quot;type&quot;: &quot;binary_comparison_operator&quot;,
                &quot;column&quot;: {
                    &quot;type&quot;: &quot;column&quot;,
                    &quot;name&quot;: &quot;title&quot;,
                    &quot;path&quot;: []
                },
                &quot;operator&quot;: {
                    &quot;type&quot;: &quot;other&quot;,
                    &quot;name&quot;: &quot;like&quot;
                },
                &quot;value&quot;: {
                    &quot;type&quot;: &quot;scalar&quot;,
                    &quot;value&quot;: &quot;Functional&quot;
                }
            }
        }
    },
    &quot;collection_relationships&quot;: {
        &quot;author_articles&quot;: {
            &quot;arguments&quot;: {},
            &quot;column_mapping&quot;: {
                &quot;id&quot;: &quot;author_id&quot;
            },
            &quot;relationship_type&quot;: &quot;array&quot;,
            &quot;source_collection_or_type&quot;: &quot;author&quot;,
            &quot;target_collection&quot;: &quot;articles&quot;
        }
    }
}
</code></pre>
<h3 id="unrelated-collections"><a class="header" href="#unrelated-collections">Unrelated Collections</a></h3>
<pre><code class="language-json">{
    &quot;collection&quot;: &quot;authors&quot;,
    &quot;arguments&quot;: {},
    &quot;query&quot;: {
        &quot;fields&quot;: {
            &quot;first_name&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;first_name&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;last_name&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;last_name&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;articles&quot;: {
                &quot;type&quot;: &quot;relationship&quot;,
                &quot;arguments&quot;: {},
                &quot;relationship&quot;: &quot;author_articles&quot;,
                &quot;query&quot;: {
                    &quot;fields&quot;: {
                        &quot;id&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;column&quot;: &quot;id&quot;,
                            &quot;arguments&quot;: {}
                        },
                        &quot;title&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;column&quot;: &quot;title&quot;,
                            &quot;arguments&quot;: {}
                        }
                    }
                }
            }
        },
        &quot;where&quot;: {
            &quot;type&quot;: &quot;exists&quot;,
            &quot;in_collection&quot;: {
                &quot;type&quot;: &quot;unrelated&quot;,
                &quot;arguments&quot;: {},
                &quot;collection&quot;: &quot;articles&quot;
            },
            &quot;where&quot;: {
                &quot;type&quot;: &quot;and&quot;,
                &quot;expressions&quot;: [
                    {
                        &quot;type&quot;: &quot;binary_comparison_operator&quot;,
                        &quot;column&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;name&quot;: &quot;author_id&quot;,
                            &quot;path&quot;: []
                        },
                        &quot;operator&quot;: {
                            &quot;type&quot;: &quot;equal&quot;
                        },
                        &quot;value&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;column&quot;: {
                                &quot;type&quot;: &quot;root_collection_column&quot;,
                                &quot;name&quot;: &quot;id&quot;
                            }
                        }
                    },
                    {
                        &quot;type&quot;: &quot;binary_comparison_operator&quot;,
                        &quot;column&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;name&quot;: &quot;title&quot;,
                            &quot;path&quot;: []
                        },
                        &quot;operator&quot;: {
                            &quot;type&quot;: &quot;other&quot;,
                            &quot;name&quot;: &quot;like&quot;
                        },
                        &quot;value&quot;: {
                            &quot;type&quot;: &quot;scalar&quot;,
                            &quot;value&quot;: &quot;Functional&quot;
                        }
                    }
                ]
            }
        }
    },
    &quot;collection_relationships&quot;: {
        &quot;author_articles&quot;: {
            &quot;arguments&quot;: {},
            &quot;column_mapping&quot;: {
                &quot;id&quot;: &quot;author_id&quot;
            },
            &quot;relationship_type&quot;: &quot;array&quot;,
            &quot;source_collection_or_type&quot;: &quot;author&quot;,
            &quot;target_collection&quot;: &quot;articles&quot;
        }
    }
}
</code></pre>
<h2 id="conjunction-of-expressions"><a class="header" href="#conjunction-of-expressions">Conjunction of expressions</a></h2>
<p>To express the conjunction of multiple expressions, specify a <code>type</code> field of <code>and</code>, and provide the expressions in the <code>expressions</code> field.</p>
<p>For example, to test if the <code>first_name</code> column is null <em>and</em> the <code>last_name</code> column is also null:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;and&quot;,
    &quot;expressions&quot;: [
        {
            &quot;type&quot;: &quot;unary_comparison_operator&quot;,
            &quot;operator&quot;: &quot;is_null&quot;,
            &quot;column&quot;: {
                &quot;name&quot;: &quot;first_name&quot;
            }
        },
        {
            &quot;type&quot;: &quot;unary_comparison_operator&quot;,
            &quot;operator&quot;: &quot;is_null&quot;,
            &quot;column&quot;: {
                &quot;name&quot;: &quot;last_name&quot;
            }
        }
    ]
}
</code></pre>
<h2 id="disjunction-of-expressions"><a class="header" href="#disjunction-of-expressions">Disjunction of expressions</a></h2>
<p>To express the disjunction of multiple expressions, specify a <code>type</code> field of <code>or</code>, and provide the expressions in the <code>expressions</code> field.</p>
<p>For example, to test if the <code>first_name</code> column is null <em>or</em> the <code>last_name</code> column is also null:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;or&quot;,
    &quot;expressions&quot;: [
        {
            &quot;type&quot;: &quot;unary_comparison_operator&quot;,
            &quot;operator&quot;: &quot;is_null&quot;,
            &quot;column&quot;: {
                &quot;name&quot;: &quot;first_name&quot;
            }
        },
        {
            &quot;type&quot;: &quot;unary_comparison_operator&quot;,
            &quot;operator&quot;: &quot;is_null&quot;,
            &quot;column&quot;: {
                &quot;name&quot;: &quot;last_name&quot;
            }
        }
    ]
}
</code></pre>
<h2 id="negation"><a class="header" href="#negation">Negation</a></h2>
<p>To express the negation of an expressions, specify a <code>type</code> field of <code>not</code>, and provide that expression in the <code>expression</code> field.</p>
<p>For example, to test if the <code>first_name</code> column is <em>not</em> null:</p>
<pre><code class="language-json">{
    &quot;type&quot;: &quot;not&quot;,
    &quot;expression&quot;: {
        &quot;type&quot;: &quot;unary_comparison_operator&quot;,
        &quot;operator&quot;: &quot;is_null&quot;,
        &quot;column&quot;: {
            &quot;name&quot;: &quot;first_name&quot;
        }
    }
}
</code></pre>
<h2 id="requirements-3"><a class="header" href="#requirements-3">Requirements</a></h2>
<p><em>TODO</em></p>
<h2 id="see-also-8"><a class="header" href="#see-also-8">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#expression"><code>Expression</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting"><a class="header" href="#sorting">Sorting</a></h1>
<p>A <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> can specify how rows should be sorted in the response.</p>
<p>The requested ordering can be found in the <code>order_by</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object.</p>
<h2 id="computing-the-ordering"><a class="header" href="#computing-the-ordering">Computing the Ordering</a></h2>
<p>To compute the ordering from the <code>order_by</code> field, data connectors should implement the following ordering between rows:</p>
<ul>
<li>Consider each element of the <code>order_by.elements</code> array in turn.</li>
<li>For each <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a>:
<ul>
<li>If <code>element.target.type</code> is <code>column</code>, then to compare two rows, compare the value in the selected column. See type <code>column</code> below.</li>
<li>If <code>element.target.type</code> is <code>star_count_aggregate</code>, compare two rows by comparing the row count of a related collection. See type <code>star_count_aggregate</code> below.</li>
<li>If <code>element.target.type</code> is <code>single_count_aggregate</code>, compare two rows by comparing a single column aggregate. See type <code>single_count_aggregate</code> below.</li>
</ul>
</li>
</ul>
<h3 id="type-column"><a class="header" href="#type-column">Type <code>column</code></a></h3>
<p>If <code>element.order_direction</code> is <code>asc</code>, then the row with the smaller column comes first. </p>
<p>If <code>element.order_direction</code> is <code>asc</code>, then the row with the smaller column comes second. </p>
<p>If the column values are incomparable, continue to the next <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a>.</p>
<p>The data connector should document, for each scalar type, a comparison function to use for any two values of that scalar type.</p>
<p>For example, a data connector might choose to use the obvious ordering for a scalar integer-valued type, but to use the database-given ordering for a string-valued type, based on a certain choice of collation.</p>
<p>For example, the following <code>query</code> requests that a collection of articles be ordered by <code>title</code> descending:</p>
<pre><code class="language-json">{
    &quot;collection&quot;: &quot;articles&quot;,
    &quot;arguments&quot;: {},
    &quot;query&quot;: {
        &quot;fields&quot;: {
            &quot;id&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;id&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;title&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;title&quot;,
                &quot;arguments&quot;: {}
            }
        },
        &quot;order_by&quot;: {
            &quot;elements&quot;: [
                {
                    &quot;target&quot;: {
                        &quot;type&quot;: &quot;column&quot;,
                        &quot;name&quot;: &quot;title&quot;,
                        &quot;path&quot;: []
                    },
                    &quot;order_direction&quot;: &quot;desc&quot;
                }
            ]
        }
    },
    &quot;collection_relationships&quot;: {}
}
</code></pre>
<p>The selected column can be chosen from a related collection by specifying the <code>path</code> property. <code>path</code> consists of a list of named <a href="specification/queries/./relationships.html">relationships</a>.</p>
<p>For example, this query sorts articles by their author's last names, and then by their first names, by traversing the relationship from articles to authors:</p>
<pre><code class="language-json">{
    &quot;collection&quot;: &quot;articles&quot;,
    &quot;arguments&quot;: {},
    &quot;query&quot;: {
        &quot;fields&quot;: {
            &quot;id&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;id&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;title&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;title&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;author&quot;: {
                &quot;type&quot;: &quot;relationship&quot;,
                &quot;arguments&quot;: {},
                &quot;relationship&quot;: &quot;article_author&quot;,
                &quot;query&quot;: {
                    &quot;fields&quot;: {
                        &quot;first_name&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;column&quot;: &quot;first_name&quot;,
                            &quot;arguments&quot;: {}
                        },
                        &quot;last_name&quot;: {
                            &quot;type&quot;: &quot;column&quot;,
                            &quot;column&quot;: &quot;last_name&quot;,
                            &quot;arguments&quot;: {}
                        }
                    }
                }
            }
        },
        &quot;order_by&quot;: {
            &quot;elements&quot;: [
                {
                    &quot;target&quot;: {
                        &quot;type&quot;: &quot;column&quot;,
                        &quot;name&quot;: &quot;last_name&quot;,
                        &quot;path&quot;: [
                            {
                                &quot;arguments&quot;: {},
                                &quot;relationship&quot;: &quot;article_author&quot;,
                                &quot;predicate&quot;: {
                                    &quot;type&quot;: &quot;and&quot;,
                                    &quot;expressions&quot;: []
                                }
                            }
                        ]
                    },
                    &quot;order_direction&quot;: &quot;asc&quot;
                },
                {
                    &quot;target&quot;: {
                        &quot;type&quot;: &quot;column&quot;,
                        &quot;name&quot;: &quot;first_name&quot;,
                        &quot;path&quot;: [
                            {
                                &quot;arguments&quot;: {},
                                &quot;relationship&quot;: &quot;article_author&quot;,
                                &quot;predicate&quot;: {
                                    &quot;type&quot;: &quot;and&quot;,
                                    &quot;expressions&quot;: []
                                }
                            }
                        ]
                    },
                    &quot;order_direction&quot;: &quot;asc&quot;
                }
            ]
        }
    },
    &quot;collection_relationships&quot;: {
        &quot;article_author&quot;: {
            &quot;arguments&quot;: {},
            &quot;column_mapping&quot;: {
                &quot;author_id&quot;: &quot;id&quot;
            },
            &quot;relationship_type&quot;: &quot;object&quot;,
            &quot;source_collection_or_type&quot;: &quot;article&quot;,
            &quot;target_collection&quot;: &quot;authors&quot;
        }
    }
}
</code></pre>
<h3 id="type-star_count_aggregate"><a class="header" href="#type-star_count_aggregate">Type <code>star_count_aggregate</code></a></h3>
<p>An ordering of type <code>star_count_aggregate</code> orders rows by a count of rows in some <a href="specification/queries/./relationships.html">related collection</a>. If the respective counts are incomparable, the ordering should continue to the next <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a>.</p>
<p>For example, this query sorts article authors by their total article count:</p>
<pre><code class="language-json">{
    &quot;collection&quot;: &quot;authors&quot;,
    &quot;arguments&quot;: {},
    &quot;query&quot;: {
        &quot;fields&quot;: {
            &quot;first_name&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;first_name&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;last_name&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;last_name&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;articles_aggregate&quot;: {
                &quot;type&quot;: &quot;relationship&quot;,
                &quot;arguments&quot;: {},
                &quot;relationship&quot;: &quot;author_articles&quot;,
                &quot;query&quot;: {
                    &quot;aggregates&quot;: {
                        &quot;count&quot;: {
                            &quot;type&quot;: &quot;star_count&quot;
                        }
                    }
                }
            }
        },
        &quot;order_by&quot;: {
            &quot;elements&quot;: [
                {
                    &quot;order_direction&quot;: &quot;desc&quot;,
                    &quot;target&quot;: {
                        &quot;type&quot;: &quot;star_count_aggregate&quot;,
                        &quot;path&quot;: [
                            {
                                &quot;arguments&quot;: {},
                                &quot;relationship&quot;: &quot;author_articles&quot;,
                                &quot;predicate&quot;: {
                                    &quot;type&quot;: &quot;and&quot;,
                                    &quot;expressions&quot;: []
                                }
                            }
                        ]
                    }
                }
            ]
        }
    },
    &quot;collection_relationships&quot;: {
        &quot;author_articles&quot;: {
            &quot;arguments&quot;: {},
            &quot;column_mapping&quot;: {
                &quot;id&quot;: &quot;author_id&quot;
            },
            &quot;relationship_type&quot;: &quot;array&quot;,
            &quot;source_collection_or_type&quot;: &quot;author&quot;,
            &quot;target_collection&quot;: &quot;articles&quot;
        }
    }
}
</code></pre>
<h3 id="type-single_count_aggregate"><a class="header" href="#type-single_count_aggregate">Type <code>single_count_aggregate</code></a></h3>
<p>An ordering of type <code>single_count_aggregate</code> orders rows by an aggregate computed over rows in some <a href="specification/queries/./relationships.html">related collection</a>. If the respective aggregates are incomparable, the ordering should continue to the next <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a>.</p>
<p>For example, this query sorts article authors by their maximum article ID:</p>
<pre><code class="language-json">{
    &quot;collection&quot;: &quot;authors&quot;,
    &quot;arguments&quot;: {},
    &quot;query&quot;: {
        &quot;fields&quot;: {
            &quot;first_name&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;first_name&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;last_name&quot;: {
                &quot;type&quot;: &quot;column&quot;,
                &quot;column&quot;: &quot;last_name&quot;,
                &quot;arguments&quot;: {}
            },
            &quot;articles_aggregate&quot;: {
                &quot;type&quot;: &quot;relationship&quot;,
                &quot;arguments&quot;: {},
                &quot;relationship&quot;: &quot;author_articles&quot;,
                &quot;query&quot;: {
                    &quot;aggregates&quot;: {
                        &quot;max_id&quot;: {
                            &quot;type&quot;: &quot;single_column&quot;,
                            &quot;column&quot;: &quot;id&quot;,
                            &quot;function&quot;: &quot;max&quot;
                        }
                    }
                }
            }
        },
        &quot;order_by&quot;: {
            &quot;elements&quot;: [
                {
                    &quot;order_direction&quot;: &quot;asc&quot;,
                    &quot;target&quot;: {
                        &quot;type&quot;: &quot;single_column_aggregate&quot;,
                        &quot;column&quot;: &quot;id&quot;,
                        &quot;function&quot;: &quot;max&quot;,
                        &quot;path&quot;: [
                            {
                                &quot;arguments&quot;: {},
                                &quot;relationship&quot;: &quot;author_articles&quot;,
                                &quot;predicate&quot;: {
                                    &quot;type&quot;: &quot;and&quot;,
                                    &quot;expressions&quot;: []
                                }
                            }
                        ]
                    }
                }
            ]
        }
    },
    &quot;collection_relationships&quot;: {
        &quot;author_articles&quot;: {
            &quot;arguments&quot;: {},
            &quot;column_mapping&quot;: {
                &quot;id&quot;: &quot;author_id&quot;
            },
            &quot;relationship_type&quot;: &quot;array&quot;,
            &quot;source_collection_or_type&quot;: &quot;author&quot;,
            &quot;target_collection&quot;: &quot;articles&quot;
        }
    }
}
</code></pre>
<h2 id="requirements-4"><a class="header" href="#requirements-4">Requirements</a></h2>
<ul>
<li>Rows in the response should be ordered according to the algorithm described above.</li>
<li>The <code>order_by</code> field should not affect the set of collection which are returned, except for their order.</li>
<li>If the <code>order_by</code> field is not provided then rows should be returned in an unspecified but deterministic order. For example, an implementation might choose to return rows in the order of their primary key or creation timestamp by default.</li>
</ul>
<h2 id="see-also-9"><a class="header" href="#see-also-9">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#orderby"><code>OrderBy</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#orderbyelement"><code>OrderByElement</code></a></li>
<li>Type <a href="specification/queries/../../reference/types.html#orderbytarget"><code>OrderByTarget</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pagination"><a class="header" href="#pagination">Pagination</a></h1>
<p>The <code>limit</code> and <code>offset</code> parameters on the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object control pagination:</p>
<ul>
<li><code>limit</code> specifies the maximum number of rows to return from a query in the rows property. <code>limit</code> does not influence the rows considered by aggregations.</li>
<li><code>offset</code>: The index of the first row to return. This affects the rows returned, and also the rows considered by aggregations.</li>
</ul>
<h2 id="requirements-5"><a class="header" href="#requirements-5">Requirements</a></h2>
<ul>
<li>If <code>limit</code> is specified, the response should contain at most that many rows.</li>
</ul>
<h2 id="see-also-10"><a class="header" href="#see-also-10">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregates"><a class="header" href="#aggregates">Aggregates</a></h1>
<p>In addition to fetching multiple rows of raw data from a collection, the query API supports fetching aggregated data.</p>
<p>Aggregates are requested in the <code>aggregates</code> field of the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object.</p>
<p>There are three types of aggregate:</p>
<ul>
<li><code>single_column</code> aggregates apply an aggregation function (as defined by the column's <a href="specification/queries/../schema/scalar-types.html">scalar type</a> in the schema response) to a column,</li>
<li><code>column_count</code> aggregates count the number of rows with non-null values in the specified columns. If the <code>distinct</code> flag is set, then the count should only count unique non-null values of those columns,</li>
<li><code>star_count</code> aggregates count all matched rows.</li>
</ul>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<p>The following query object requests the aggregated sum of all order totals, along with the count of all orders, and the count of all orders which have associated invoices (via the nullable <code>invoice_id</code> column):</p>
<pre><code class="language-json">{
  &quot;collection&quot;: [&quot;orders&quot;],
  &quot;collection_relationships&quot;: {},
  &quot;query&quot;: {
    &quot;aggregates&quot;: {
      &quot;orders_total&quot;: {
        &quot;type&quot;: &quot;single_column&quot;,
        &quot;function&quot;: &quot;sum&quot;,
        &quot;column&quot;: &quot;total&quot;
      },
      &quot;invoiced_orders_count&quot;: {
        &quot;type&quot;: &quot;column_count&quot;,
        &quot;columns&quot;: [&quot;invoice_id&quot;]
      },
      &quot;orders_count&quot;: {
        &quot;type&quot;: &quot;star_count&quot;
      }
    }
  }
}
</code></pre>
<p>In this case, the query has no predicate function, so all three aggregates would be computed over all rows.</p>
<h2 id="requirements-6"><a class="header" href="#requirements-6">Requirements</a></h2>
<ul>
<li>Each aggregate should be computed over all rows that match the <code>Query</code>.</li>
<li>Each requested aggregate must be returned in the <code>aggregates</code> property on the <a href="specification/queries/../../reference/types.html#queryresponse"><code>QueryResponse</code></a> object, using the same key as used to request it.</li>
</ul>
<h2 id="see-also-11"><a class="header" href="#see-also-11">See also</a></h2>
<ul>
<li>Type <a href="specification/queries/../../reference/types.html#aggregate"><code>Aggregate</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arguments"><a class="header" href="#arguments">Arguments</a></h1>
<p>Data connectors can parameterize their datasets with two types of arguments:</p>
<ul>
<li><em>Collection arguments</em> parameterize the entire dataset, and are provided in queries wherever the collection is referenced, either directly, or via relationships,</li>
<li><em>Column arguments</em> parameterize single columns, and are optional, but can be provided</li>
</ul>
<h2 id="collection-arguments-1"><a class="header" href="#collection-arguments-1">Collection Arguments</a></h2>
<h3 id="relationships"><a class="header" href="#relationships">Relationships</a></h3>
<h3 id="mutations"><a class="header" href="#mutations">Mutations</a></h3>
<h2 id="column-arguments"><a class="header" href="#column-arguments">Column Arguments</a></h2>
<h3 id="mutations-1"><a class="header" href="#mutations-1">Mutations</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relationships-1"><a class="header" href="#relationships-1">Relationships</a></h1>
<p>Queries can request data from other collections via relationships. A relationship identifies rows in one collection (the &quot;source collection&quot;) with possibly-many related rows in a second collection (the &quot;target collection&quot;) via a <em>column mapping</em>.</p>
<p>A column mapping is a set of pairs of columns - each consisting of one column from the source collection and one column from the target collection - which must be pairwise equal in order for a pair of rows to be considered equal.</p>
<p>Relationships are not used only for fetching data - they are used in practically all features of data connectors:</p>
<ul>
<li>Filters can reference columns across relationships</li>
<li>Sorting can be defined in terms of row counts and aggregates over related collections</li>
<li><code>EXISTS</code> expressions in predicates can query related collections</li>
<li>Insert mutations can insert related data along with rows for a source collection</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>A <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a> can optionally specify one or more sets of variables which can be referenced throughout the <a href="specification/queries/../../reference/types.html#query"><code>Query</code></a> object. </p>
<p>Query variables will only be provided if the <code>foreach</code> <a href="specification/queries/../capabilities.html">capability</a> is advertised in the capabilities response.</p>
<p>The intent is that the data connector should attempt to perform multiple versions of the query in parallel - one instance of the query for each set of variables. For each set of variables, each variable value should be substituted wherever it is referenced in the query - for example in a <a href="specification/queries/../../reference/types.html#comparisonvalue"><code>ComparisonValue</code></a>.</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<p>In the following query, we fetch two rowsets of article data. In each rowset, the rows are filtered based on the <code>author_id</code> column, and the prescribed <code>author_id</code> is determined by a variable. The choice of <code>author_id</code> varies between rowsets.</p>
<p>The result contains one rowset containing articles from the author with ID <code>1</code>, and a second for the author with ID <code>2</code>.</p>
<pre><code class="language-json">{
  &quot;collection&quot;: [&quot;articles&quot;],
  &quot;collection_relationships&quot;: [],
  &quot;query&quot;: {
    &quot;fields&quot;: {
      &quot;title&quot;: {
        &quot;type&quot;: &quot;column&quot;,
        &quot;column&quot;: &quot;title&quot;
      }
    },
    &quot;predicate&quot;: {
        &quot;type&quot;: &quot;binary_comparison_operator&quot;,
        &quot;operator&quot;: {
            &quot;type&quot;: &quot;equal&quot;
        },
        &quot;column&quot;: {
            &quot;name&quot;: &quot;author_id&quot;
        },
        &quot;value&quot;: {
            &quot;type&quot;: &quot;variable&quot;,
            &quot;name&quot;: &quot;author_id&quot;
        }
    }
  },
  &quot;variables&quot;: [
    { &quot;author_id&quot;: &quot;1&quot; },
    { &quot;author_id&quot;: &quot;2&quot; }
  ]
}
</code></pre>
<h2 id="requirements-7"><a class="header" href="#requirements-7">Requirements</a></h2>
<ul>
<li>If <code>variables</code> are provided in the <a href="specification/queries/../../reference/types.html#queryrequest"><code>QueryRequest</code></a>, then the <a href="specification/queries/../../reference/types.html#queryresponse"><code>QueryResponse</code></a> should contain one <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a> for each set of variables.</li>
<li>If <code>variables</code> are not provided, the data connector should return a single <a href="specification/queries/../../reference/types.html#rowset"><code>RowSet</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutations-2"><a class="header" href="#mutations-2">Mutations</a></h1>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explain"><a class="header" href="#explain">Explain</a></h1>
<p>The explain endpoint accepts a <a href="specification/./queries/README.html">query</a> request, but without actually executing the query, returns a representation of the <em>execution plan</em>.</p>
<h2 id="request-6"><a class="header" href="#request-6">Request</a></h2>
<pre><code>POST /explain
</code></pre>
<h2 id="request-7"><a class="header" href="#request-7">Request</a></h2>
<p>See <a href="specification/../reference/types.html#queryrequest"><code>QueryRequest</code></a></p>
<h2 id="response-5"><a class="header" href="#response-5">Response</a></h2>
<p>See <a href="specification/../reference/types.html#explainresponse"><code>ExplainResponse</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>In this tutorial, we will walk through the <em>reference implementation</em> of the specification, which will illustrate how to implement data connectors from scratch.</p>
<p>The reference implementation is written in Rust, but it should be possible to follow along using any language of your choice, as long as you can implement a basic web server and implement serializers and deserializers for the data formats involved.</p>
<p>It is recommended that you follow along chapter-by-chapter, as each will build on the last.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>The reference implementation will serve queries and mutations based on in-memory data read from CSV files.</p>
<p>First, we will define some types to represent the data in the CSV files. The structure of these types will also be reflected in our data connector's schema: </p>
<pre><code class="language-rust no_run noplayground">type Row = BTreeMap&lt;String, serde_json::Value&gt;;</code></pre>
<p>Our data connector's application state will consist of collections of each of these types:</p>
<pre><code class="language-rust no_run noplayground">#[derive(Debug, Clone)]
pub struct AppState {
    pub articles: BTreeMap&lt;i64, Row&gt;,
    pub authors: BTreeMap&lt;i64, Row&gt;,
    pub metrics: Metrics,
}</code></pre>
<p>In our <code>main</code> function, the data connector reads the initial data from the CSV files, and creates the <code>AppState</code>, before starting a web server with the required endpoints:</p>
<pre><code class="language-rust no_run noplayground">#[tokio::main]
async fn main() {
    let app_state = Arc::new(Mutex::new(init_app_state()));

    let app = Router::new()
        .route(&quot;/healthz&quot;, get(get_healthz))
        .route(&quot;/metrics&quot;, get(get_metrics))
        .route(&quot;/capabilities&quot;, get(get_capabilities))
        .route(&quot;/schema&quot;, get(get_schema))
        .route(&quot;/query&quot;, post(post_query))
        .route(&quot;/mutation&quot;, post(post_mutation))
        .route(&quot;/explain&quot;, post(post_explain))
        .layer(axum::middleware::from_fn_with_state(
            app_state.clone(),
            metrics_middleware,
        ))
        .with_state(app_state);

    // run it with hyper on localhost:8100
    axum::Server::bind(&amp;&quot;0.0.0.0:8100&quot;.parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}</code></pre>
<p>In the next chapters, we will look at the implementation of each of these endpoints in turn.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capabilities-1"><a class="header" href="#capabilities-1">Capabilities</a></h1>
<p>The <a href="tutorial/../specification/capabilities.html">capabilities endpoint</a> should return data describing which features the data connector can implement, along with a range of versions of this specification that the data connector claims to implement.</p>
<p>The reference implementation returns a static <code>CapabilitiesResponse</code>:</p>
<pre><code class="language-rust no_run noplayground">async fn get_capabilities() -&gt; Json&lt;models::CapabilitiesResponse&gt; {
    let empty = serde_json::to_value(BTreeMap::&lt;String, ()&gt;::new()).unwrap();
    Json(models::CapabilitiesResponse {
        versions: &quot;^0.1.0&quot;.into(),
        capabilities: models::Capabilities {
            explain: None,
            query: Some(models::QueryCapabilities {
                foreach: Some(empty.clone()),
                order_by_aggregate: Some(empty.clone()),
                relation_comparisons: Some(empty.clone()),
            }),
            mutations: Some(models::MutationCapabilities {
                returning: Some(empty.clone()),
                nested_inserts: Some(empty.clone()),
            }),
            relationships: Some(empty),
        },
    })
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema-2"><a class="header" href="#schema-2">Schema</a></h1>
<p>The <a href="tutorial/../specification/schema/README.html">schema endpoint</a> should return data describing the data connector's scalar and object types, along with any collections, functions and procedures which are exposed.</p>
<pre><code class="language-rust no_run noplayground">async fn get_schema() -&gt; Json&lt;models::SchemaResponse&gt; {
    // ...
    Json(models::SchemaResponse {
        scalar_types,
        object_types,
        collections,
        functions,
        procedures,
    })
}</code></pre>
<h2 id="scalar-types-1"><a class="header" href="#scalar-types-1">Scalar Types</a></h2>
<pre><code class="language-rust no_run noplayground">    let scalar_types = BTreeMap::from_iter([
        (
            &quot;String&quot;.into(),
            models::ScalarType {
                aggregate_functions: BTreeMap::new(),
                comparison_operators: BTreeMap::from_iter([(
                    &quot;like&quot;.into(),
                    models::ComparisonOperatorDefinition {
                        argument_type: models::Type::Named {
                            name: &quot;String&quot;.into(),
                        },
                    },
                )]),
                update_operators: BTreeMap::new(),
            },
        ),
        (
            &quot;Int&quot;.into(),
            models::ScalarType {
                aggregate_functions: BTreeMap::from_iter([
                    (
                        &quot;max&quot;.into(),
                        models::AggregateFunctionDefinition {
                            result_type: models::Type::Nullable {
                                underlying_type: Box::new(models::Type::Named {
                                    name: &quot;Int&quot;.into(),
                                }),
                            },
                        },
                    ),
                    (
                        &quot;min&quot;.into(),
                        models::AggregateFunctionDefinition {
                            result_type: models::Type::Nullable {
                                underlying_type: Box::new(models::Type::Named {
                                    name: &quot;Int&quot;.into(),
                                }),
                            },
                        },
                    ),
                ]),
                comparison_operators: BTreeMap::from_iter([]),
                update_operators: BTreeMap::new(),
            },
        ),
    ]);</code></pre>
<h2 id="object-types-1"><a class="header" href="#object-types-1">Object Types</a></h2>
<p>For each collection, we define an object type for its rows:</p>
<pre><code class="language-rust no_run noplayground">    let object_types = BTreeMap::from_iter([
        (&quot;article&quot;.into(), article_type),
        (&quot;author&quot;.into(), author_type),
    ]);</code></pre>
<h3 id="author"><a class="header" href="#author">Author</a></h3>
<pre><code class="language-rust no_run noplayground">    let author_type = models::ObjectType {
        description: Some(&quot;An author&quot;.into()),
        fields: BTreeMap::from_iter([
            (
                &quot;id&quot;.into(),
                models::ObjectField {
                    description: Some(&quot;The author's primary key&quot;.into()),
                    arguments: BTreeMap::new(),
                    r#type: models::Type::Named { name: &quot;Int&quot;.into() },
                },
            ),
            (
                &quot;first_name&quot;.into(),
                models::ObjectField {
                    description: Some(&quot;The author's first name&quot;.into()),
                    arguments: BTreeMap::new(),
                    r#type: models::Type::Named {
                        name: &quot;String&quot;.into(),
                    },
                },
            ),
            (
                &quot;last_name&quot;.into(),
                models::ObjectField {
                    description: Some(&quot;The author's last name&quot;.into()),
                    arguments: BTreeMap::new(),
                    r#type: models::Type::Named {
                        name: &quot;String&quot;.into(),
                    },
                },
            ),
        ]),
    };</code></pre>
<h3 id="article"><a class="header" href="#article">Article</a></h3>
<pre><code class="language-rust no_run noplayground">    let article_type = models::ObjectType {
        description: Some(&quot;An article&quot;.into()),
        fields: BTreeMap::from_iter([
            (
                &quot;id&quot;.into(),
                models::ObjectField {
                    description: Some(&quot;The article's primary key&quot;.into()),
                    arguments: BTreeMap::new(),
                    r#type: models::Type::Named { name: &quot;Int&quot;.into() },
                },
            ),
            (
                &quot;title&quot;.into(),
                models::ObjectField {
                    description: Some(&quot;The article's title&quot;.into()),
                    arguments: BTreeMap::new(),
                    r#type: models::Type::Named {
                        name: &quot;String&quot;.into(),
                    },
                },
            ),
            (
                &quot;author_id&quot;.into(),
                models::ObjectField {
                    description: Some(&quot;The article's author ID&quot;.into()),
                    arguments: BTreeMap::new(),
                    r#type: models::Type::Named { name: &quot;Int&quot;.into() },
                },
            ),
        ]),
    };</code></pre>
<h2 id="collections-1"><a class="header" href="#collections-1">Collections</a></h2>
<p>We define each collection's schema using the type information defined above:</p>
<pre><code class="language-rust no_run noplayground">    let collections = vec![
        articles_collection,
        authors_collection,
        articles_by_author_collection,
    ];</code></pre>
<h3 id="author-1"><a class="header" href="#author-1">Author</a></h3>
<pre><code class="language-rust no_run noplayground">    let authors_collection = models::CollectionInfo {
        name: &quot;authors&quot;.into(),
        description: Some(&quot;A collection of authors&quot;.into()),
        collection_type: &quot;author&quot;.into(),
        arguments: BTreeMap::new(),
        deletable: false,
        insertable_columns: None,
        updatable_columns: None,
        foreign_keys: BTreeMap::new(),
        uniqueness_constraints: BTreeMap::from_iter([(
            &quot;AuthorByID&quot;.into(),
            models::UniquenessConstraint {
                unique_columns: vec![&quot;id&quot;.into()],
            },
        )]),
    };</code></pre>
<h3 id="article-1"><a class="header" href="#article-1">Article</a></h3>
<pre><code class="language-rust no_run noplayground">    let articles_collection = models::CollectionInfo {
        name: &quot;articles&quot;.into(),
        description: Some(&quot;A collection of articles&quot;.into()),
        collection_type: &quot;article&quot;.into(),
        arguments: BTreeMap::new(),
        deletable: false,
        insertable_columns: None,
        updatable_columns: None,
        foreign_keys: BTreeMap::new(),
        uniqueness_constraints: BTreeMap::from_iter([(
            &quot;ArticleByID&quot;.into(),
            models::UniquenessConstraint {
                unique_columns: vec![&quot;id&quot;.into()],
            },
        )]),
    };</code></pre>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<p>The schema defines a list of functions, each including its input and output <a href="tutorial/../specification/types.html">types</a>.</p>
<h3 id="get-latest-article"><a class="header" href="#get-latest-article">Get Latest Article</a></h3>
<p><em>TODO</em></p>
<h2 id="procedures-2"><a class="header" href="#procedures-2">Procedures</a></h2>
<p>The schema defines a list of procedures, each including its input and output <a href="tutorial/../specification/types.html">types</a>.</p>
<h3 id="upsert-article"><a class="header" href="#upsert-article">Upsert Article</a></h3>
<p>As an example, we define an <em>upsert</em> procedure for the article collection defined above. The procedure will accept an input argument of type <code>article</code>, and returns a nulcollection <code>article</code>, representing the state of the article before the update, if it were already present.</p>
<pre><code class="language-rust no_run noplayground">    let upsert_article = models::ProcedureInfo {
        name: &quot;upsert_article&quot;.into(),
        description: Some(&quot;Insert or update an article&quot;.into()),
        arguments: BTreeMap::from_iter([(
            &quot;article&quot;.into(),
            models::ArgumentInfo {
                description: Some(&quot;The article to insert or update&quot;.into()),
                argument_type: models::Type::Named {
                    name: &quot;article&quot;.into(),
                },
            },
        )]),
        result_type: models::Type::Nullable {
            underlying_type: Box::new(models::Type::Named {
                name: &quot;article&quot;.into(),
            }),
        },
    };</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queries-1"><a class="header" href="#queries-1">Queries</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-queries"><a class="header" href="#simple-queries">Simple Queries</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relationships-2"><a class="header" href="#relationships-2">Relationships</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregates-1"><a class="header" href="#aggregates-1">Aggregates</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-1"><a class="header" href="#variables-1">Variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutations-3"><a class="header" href="#mutations-3">Mutations</a></h1>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-1"><a class="header" href="#types-1">Types</a></h1>
<h2 id="aggregate"><a class="header" href="#aggregate"><code>Aggregate</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum Aggregate {
    // TODO: do we need aggregation row limits?
    ColumnCount {
        /// The column to apply the count aggregate function to
        column: String,
        /// Whether or not only distinct items should be counted
        distinct: bool,
    },
    SingleColumn {
        /// The column to apply the aggregation function to
        column: String,
        /// Single column aggregate function name.
        function: String,
    },
    StarCount {},
}</code></pre>
<h2 id="aggregatefunctiondefinition"><a class="header" href="#aggregatefunctiondefinition"><code>AggregateFunctionDefinition</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of an aggregation function on a scalar type
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct AggregateFunctionDefinition {
    /// The scalar or object type of the result of this function
    pub result_type: Type,
}</code></pre>
<h2 id="argument"><a class="header" href="#argument"><code>Argument</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum Argument {
    /// The argument is provided by reference to a variable
    Variable { name: String },
    /// The argument is provided as a literal value
    Literal { value: serde_json::Value },
}</code></pre>
<h2 id="argumentinfo"><a class="header" href="#argumentinfo"><code>ArgumentInfo</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ArgumentInfo {
    /// Argument description
    pub description: Option&lt;String&gt;,
    /// The name of the type of this argument
    #[serde(rename = &quot;type&quot;)]
    pub argument_type: Type,
}</code></pre>
<h2 id="binaryarraycomparisonoperator"><a class="header" href="#binaryarraycomparisonoperator"><code>BinaryArrayComparisonOperator</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum BinaryArrayComparisonOperator {
    In,
}</code></pre>
<h2 id="binarycomparisonoperator"><a class="header" href="#binarycomparisonoperator"><code>BinaryComparisonOperator</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum BinaryComparisonOperator {
    Equal,
    // should we rename this? To what?
    Other { name: String },
}</code></pre>
<h2 id="capabilities-2"><a class="header" href="#capabilities-2"><code>Capabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// Describes the features of the specification which a data connector implements.
#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Capabilities {
    pub query: Option&lt;QueryCapabilities&gt;,
    pub explain: Option&lt;serde_json::Value&gt;,
    pub mutations: Option&lt;MutationCapabilities&gt;,
    pub relationships: Option&lt;serde_json::Value&gt;,
}</code></pre>
<h2 id="capabilitiesresponse"><a class="header" href="#capabilitiesresponse"><code>CapabilitiesResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CapabilitiesResponse {
    pub versions: String,
    pub capabilities: Capabilities,
}</code></pre>
<h2 id="procedureinfo"><a class="header" href="#procedureinfo"><code>ProcedureInfo</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ProcedureInfo {
    /// The name of the procedure
    pub name: String,
    /// Column description
    pub description: Option&lt;String&gt;,
    /// Any arguments that this collection requires
    pub arguments: BTreeMap&lt;String, ArgumentInfo&gt;,
    /// The name of the result type
    pub result_type: Type,
}</code></pre>
<h2 id="comparisonoperatordefinition"><a class="header" href="#comparisonoperatordefinition"><code>ComparisonOperatorDefinition</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of a comparison operator on a scalar type
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ComparisonOperatorDefinition {
    /// The type of the argument to this operator
    pub argument_type: Type,
}</code></pre>
<h2 id="comparisontarget"><a class="header" href="#comparisontarget"><code>ComparisonTarget</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum ComparisonTarget {
    Column {
        /// The name of the column
        name: String,
        /// Any relationships to traverse to reach this column
        path: Vec&lt;PathElement&gt;,
    },
    RootCollectionColumn {
        /// The name of the column
        name: String,
    },
}</code></pre>
<h2 id="comparisonvalue"><a class="header" href="#comparisonvalue"><code>ComparisonValue</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum ComparisonValue {
    Column { column: Box&lt;ComparisonTarget&gt; },
    Scalar { value: serde_json::Value },
    Variable { name: String },
}</code></pre>
<h2 id="existsincollection"><a class="header" href="#existsincollection"><code>ExistsInCollection</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum ExistsInCollection {
    Related {
        relationship: String,
        /// Values to be provided to any collection arguments
        arguments: BTreeMap&lt;String, RelationshipArgument&gt;,
    },
    Unrelated {
        /// The name of a collection
        collection: String,
        /// Values to be provided to any collection arguments
        arguments: BTreeMap&lt;String, RelationshipArgument&gt;,
    },
}</code></pre>
<h2 id="explainresponse"><a class="header" href="#explainresponse"><code>ExplainResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ExplainResponse {
    /// A list of human-readable key-value pairs describing
    /// a query execution plan. For example, a connector for
    /// a relational database might return the generated SQL
    /// and/or the output of the `EXPLAIN` command. An API-based
    /// connector might encode a list of statically-known API
    /// calls which would be made.
    pub details: BTreeMap&lt;String, String&gt;,
}</code></pre>
<h2 id="expression"><a class="header" href="#expression"><code>Expression</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum Expression {
    And {
        expressions: Vec&lt;Expression&gt;,
    },
    Or {
        expressions: Vec&lt;Expression&gt;,
    },
    Not {
        expression: Box&lt;Expression&gt;,
    },
    UnaryComparisonOperator {
        column: Box&lt;ComparisonTarget&gt;,
        operator: Box&lt;UnaryComparisonOperator&gt;,
    },
    BinaryComparisonOperator {
        column: Box&lt;ComparisonTarget&gt;,
        operator: Box&lt;BinaryComparisonOperator&gt;,
        value: Box&lt;ComparisonValue&gt;,
    },
    BinaryArrayComparisonOperator {
        column: Box&lt;ComparisonTarget&gt;,
        operator: Box&lt;BinaryArrayComparisonOperator&gt;,
        values: Vec&lt;ComparisonValue&gt;,
    },
    Exists {
        in_collection: Box&lt;ExistsInCollection&gt;,
        #[serde(rename = &quot;where&quot;)]
        predicate: Box&lt;Expression&gt;,
    },
}</code></pre>
<h2 id="field"><a class="header" href="#field"><code>Field</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum Field {
    Column {
        column: String,
        /// Values to be provided to any field arguments
        arguments: BTreeMap&lt;String, Argument&gt;,
    },
    Relationship {
        query: Box&lt;Query&gt;,
        /// The name of the relationship to follow for the subquery
        relationship: String,
        /// Values to be provided to any collection arguments
        arguments: BTreeMap&lt;String, RelationshipArgument&gt;,
    },
}</code></pre>
<h2 id="foreignkeyconstraint"><a class="header" href="#foreignkeyconstraint"><code>ForeignKeyConstraint</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ForeignKeyConstraint {
    /// The columns on which you want want to define the foreign key.
    pub column_mapping: BTreeMap&lt;String, String&gt;,
    /// The name of a collection
    pub foreign_collection: String,
}</code></pre>
<h2 id="functioninfo"><a class="header" href="#functioninfo"><code>FunctionInfo</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct FunctionInfo {
    /// The name of the function
    pub name: String,
    /// Description of the function
    pub description: Option&lt;String&gt;,
    /// Any arguments that this collection requires
    pub arguments: BTreeMap&lt;String, ArgumentInfo&gt;,
    /// The name of the function's result type
    pub result_type: Type,
}</code></pre>
<h2 id="insertfieldschema"><a class="header" href="#insertfieldschema"><code>InsertFieldSchema</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum InsertFieldSchema {
    ArrayRelation {
        /// The name of the array relationship over which the related rows must be inserted
        relationship: String,
    },
    Column {
        /// The name of the column that this field should be inserted into
        column: String,
    },
    ObjectRelation {
        insertion_order: ObjectRelationInsertionOrder,
        /// The name of the object relationship over which the related row must be inserted
        relationship: String,
    },
}</code></pre>
<h2 id="mutationcapabilities"><a class="header" href="#mutationcapabilities"><code>MutationCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MutationCapabilities {
    /// Whether or not nested inserts to related collections are supported
    pub nested_inserts: Option&lt;serde_json::Value&gt;,
    pub returning: Option&lt;serde_json::Value&gt;,
}</code></pre>
<h2 id="mutationoperation"><a class="header" href="#mutationoperation"><code>MutationOperation</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum MutationOperation {
    Delete {
        /// The fields to return for the rows affected by this delete operation
        returning_fields: Option&lt;IndexMap&lt;String, Field&gt;&gt;,
        /// The name of a collection
        collection: String,
        #[serde(rename = &quot;where&quot;)]
        predicate: Option&lt;Expression&gt;,
    },
    Insert {
        post_insert_check: Option&lt;Expression&gt;,
        /// The fields to return for the rows affected by this insert operation
        returning_fields: Option&lt;IndexMap&lt;String, Field&gt;&gt;,
        /// The rows to insert into the collection
        rows: Vec&lt;BTreeMap&lt;String, serde_json::Value&gt;&gt;,
        /// The name of a collection
        collection: String,
    },
    Update {
        post_update_check: Option&lt;Expression&gt;,
        /// The fields to return for the rows affected by this update operation
        returning_fields: Option&lt;IndexMap&lt;String, Field&gt;&gt;,
        /// The name of a collection
        collection: String,
        /// The updates to make to the matched rows in the collection
        updates: Vec&lt;RowUpdate&gt;,
        #[serde(rename = &quot;where&quot;)]
        r#where: Option&lt;Expression&gt;,
    },
    Procedure {
        /// The name of a procedure
        name: String,
        /// Any named procedure arguments
        arguments: BTreeMap&lt;String, serde_json::Value&gt;,
        /// The fields to return
        fields: Option&lt;IndexMap&lt;String, Field&gt;&gt;,
    },
}</code></pre>
<h2 id="mutationoperationresults"><a class="header" href="#mutationoperationresults"><code>MutationOperationResults</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MutationOperationResults {
    /// The number of rows affected by the mutation operation
    pub affected_rows: u32,
    /// The rows affected by the mutation operation
    pub returning: Option&lt;Vec&lt;IndexMap&lt;String, RowFieldValue&gt;&gt;&gt;,
}</code></pre>
<h2 id="mutationrequest"><a class="header" href="#mutationrequest"><code>MutationRequest</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MutationRequest {
    /// The schema by which to interpret row data specified in any insert operations in this request
    pub insert_schema: Vec&lt;CollectionInsertSchema&gt;,
    /// The mutation operations to perform
    pub operations: Vec&lt;MutationOperation&gt;,
    /// The relationships between collections involved in the entire mutation request
    pub collection_relationships: BTreeMap&lt;String, Relationship&gt;,
}</code></pre>
<h2 id="mutationresponse"><a class="header" href="#mutationresponse"><code>MutationResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct MutationResponse {
    /// The results of each mutation operation, in the same order as they were received
    pub operation_results: Vec&lt;MutationOperationResults&gt;,
}</code></pre>
<h2 id="objectfield"><a class="header" href="#objectfield"><code>ObjectField</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of an object field
#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ObjectField {
    /// Description of this field
    pub description: Option&lt;String&gt;,
    /// Any arguments that this object field accepts
    pub arguments: BTreeMap&lt;String, ArgumentInfo&gt;,
    /// The type of this field
    #[serde(rename = &quot;type&quot;)]
    pub r#type: Type,
}</code></pre>
<h2 id="objectrelationinsertionorder"><a class="header" href="#objectrelationinsertionorder"><code>ObjectRelationInsertionOrder</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum ObjectRelationInsertionOrder {
    BeforeParent,
    AfterParent,
}</code></pre>
<h2 id="objecttype"><a class="header" href="#objecttype"><code>ObjectType</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of an object type
#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ObjectType {
    /// Description of this type
    pub description: Option&lt;String&gt;,
    /// Fields defined on this object type
    pub fields: BTreeMap&lt;String, ObjectField&gt;,
}</code></pre>
<h2 id="orderby"><a class="header" href="#orderby"><code>OrderBy</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OrderBy {
    /// The elements to order by, in priority order
    pub elements: Vec&lt;OrderByElement&gt;,
}</code></pre>
<h2 id="orderbyelement"><a class="header" href="#orderbyelement"><code>OrderByElement</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct OrderByElement {
    pub order_direction: OrderDirection,
    pub target: OrderByTarget,
}</code></pre>
<h2 id="orderbytarget"><a class="header" href="#orderbytarget"><code>OrderByTarget</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum OrderByTarget {
    Column {
        /// The name of the column
        name: String,
        /// Any relationships to traverse to reach this column
        path: Vec&lt;PathElement&gt;,
    },
    SingleColumnAggregate {
        /// The column to apply the aggregation function to
        column: String,
        /// Single column aggregate function name.
        function: String,
        /// Non-empty collection of relationships to traverse
        path: Vec&lt;PathElement&gt;,
    },
    StarCountAggregate {
        /// Non-empty collection of relationships to traverse
        path: Vec&lt;PathElement&gt;,
    },
}</code></pre>
<h2 id="orderdirection"><a class="header" href="#orderdirection"><code>OrderDirection</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum OrderDirection {
    Asc,
    Desc,
}</code></pre>
<h2 id="pathelement"><a class="header" href="#pathelement"><code>PathElement</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct PathElement {
    /// The name of the relationship to follow
    pub relationship: String,
    /// Values to be provided to any collection arguments
    pub arguments: BTreeMap&lt;String, RelationshipArgument&gt;,
    /// A predicate expression to apply to the target collection
    pub predicate: Box&lt;Expression&gt;,
}</code></pre>
<h2 id="query"><a class="header" href="#query"><code>Query</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Query {
    /// Aggregate fields of the query
    pub aggregates: Option&lt;IndexMap&lt;String, Aggregate&gt;&gt;,
    /// Fields of the query
    pub fields: Option&lt;IndexMap&lt;String, Field&gt;&gt;,
    /// Optionally limit to N results
    pub limit: Option&lt;u32&gt;,
    /// Optionally offset from the Nth result
    pub offset: Option&lt;u32&gt;,
    pub order_by: Option&lt;OrderBy&gt;,
    #[serde(rename = &quot;where&quot;)]
    pub predicate: Option&lt;Expression&gt;,
}</code></pre>
<h2 id="querycapabilities"><a class="header" href="#querycapabilities"><code>QueryCapabilities</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct QueryCapabilities {
    /// Does the agent support comparisons that involve related collections (ie. joins)?
    pub relation_comparisons: Option&lt;serde_json::Value&gt;,
    /// Does the agent support ordering by an aggregated array relationship?
    pub order_by_aggregate: Option&lt;serde_json::Value&gt;,
    /// Does the agent support foreach queries, i.e. queries with variables
    pub foreach: Option&lt;serde_json::Value&gt;,
}</code></pre>
<h2 id="queryrequest"><a class="header" href="#queryrequest"><code>QueryRequest</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// This is the request body of the query POST endpoint
#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct QueryRequest {
    /// The name of a collection
    pub collection: String,
    /// The query syntax tree
    pub query: Query,
    /// Values to be provided to any collection arguments
    pub arguments: BTreeMap&lt;String, Argument&gt;,
    /// Any relationships between collections involved in the query request
    pub collection_relationships: BTreeMap&lt;String, Relationship&gt;,
    /// One set of named variables for each rowset to fetch. Each variable set
    /// should be subtituted in turn, and a fresh set of rows returned.
    pub variables: Option&lt;Vec&lt;BTreeMap&lt;String, serde_json::Value&gt;&gt;&gt;,
}</code></pre>
<h2 id="queryresponse"><a class="header" href="#queryresponse"><code>QueryResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
/// Query responses may return multiple RowSets when using foreach queries
/// Else, there should always be exactly one RowSet
pub struct QueryResponse(pub Vec&lt;RowSet&gt;);</code></pre>
<h2 id="relationship"><a class="header" href="#relationship"><code>Relationship</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct Relationship {
    /// A mapping between columns on the source collection to columns on the target collection
    pub column_mapping: BTreeMap&lt;String, String&gt;,
    pub relationship_type: RelationshipType,
    /// The name of the collection or object type which is the source of this relationship
    pub source_collection_or_type: String,
    /// The name of a collection
    pub target_collection: String,
    /// Values to be provided to any collection arguments
    pub arguments: BTreeMap&lt;String, RelationshipArgument&gt;,
}</code></pre>
<h2 id="relationshiptype"><a class="header" href="#relationshiptype"><code>RelationshipType</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum RelationshipType {
    Object,
    Array,
}</code></pre>
<h2 id="rowfieldvalue"><a class="header" href="#rowfieldvalue"><code>RowFieldValue</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(untagged)]
pub enum RowFieldValue {
    Relationship(RowSet),
    Column(serde_json::Value),
}</code></pre>
<h2 id="rowset"><a class="header" href="#rowset"><code>RowSet</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct RowSet {
    /// The results of the aggregates returned by the query
    pub aggregates: Option&lt;IndexMap&lt;String, serde_json::Value&gt;&gt;,
    /// The rows returned by the query, corresponding to the query's fields
    pub rows: Option&lt;Vec&lt;IndexMap&lt;String, RowFieldValue&gt;&gt;&gt;,
}</code></pre>
<h2 id="rowupdate"><a class="header" href="#rowupdate"><code>RowUpdate</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum RowUpdate {
    CustomOperator {
        /// The name of the column in the row
        column: String,
        operator_name: String,
        /// The value to use with the column operator
        value: serde_json::Value,
    },
    Set {
        /// The name of the column in the row
        column: String,
        /// The value to use with the column operator
        value: serde_json::Value,
    },
}</code></pre>
<h2 id="scalartype"><a class="header" href="#scalartype"><code>ScalarType</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of a scalar type, i.e. types that can be used as the types of columns.
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct ScalarType {
    /// A map from aggregate function names to their definitions. Result type names must be defined scalar types declared in ScalarTypesCapabilities.
    pub aggregate_functions: BTreeMap&lt;String, AggregateFunctionDefinition&gt;,
    /// A map from comparison operator names to their definitions. Argument type names must be defined scalar types declared in ScalarTypesCapabilities.
    pub comparison_operators: BTreeMap&lt;String, ComparisonOperatorDefinition&gt;,
    /// A map from update operator names to their definitions.
    pub update_operators: BTreeMap&lt;String, UpdateOperatorDefinition&gt;,
}</code></pre>
<h2 id="schemaresponse"><a class="header" href="#schemaresponse"><code>SchemaResponse</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct SchemaResponse {
    /// A list of scalar types which will be used as the types of collection columns
    pub scalar_types: BTreeMap&lt;String, ScalarType&gt;,
    /// A list of object types which can be used as the types of arguments, or return types of procedures.
    /// Names should not overlap with collection names or scalar type names.
    pub object_types: BTreeMap&lt;String, ObjectType&gt;,
    /// Collections which are available for queries and/or mutations
    pub collections: Vec&lt;CollectionInfo&gt;,
    /// Functions (i.e. collections which return a single column and row)
    pub functions: Vec&lt;FunctionInfo&gt;,
    /// Procedures which are available for execution as part of mutations
    pub procedures: Vec&lt;ProcedureInfo&gt;,
}</code></pre>
<h2 id="collectioninfo"><a class="header" href="#collectioninfo"><code>CollectionInfo</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[skip_serializing_none]
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CollectionInfo {
    /// The name of the collection
    ///
    /// Note: these names are abstract - there is no requirement that this name correspond to
    /// the name of an actual collection in the database.
    pub name: String,
    /// Description of the collection
    pub description: Option&lt;String&gt;,
    /// Any arguments that this collection requires
    pub arguments: BTreeMap&lt;String, ArgumentInfo&gt;,
    /// The name of the collection's object type
    #[serde(rename = &quot;type&quot;)]
    pub collection_type: String,
    /// The set of names of insercollection columns, or null if inserts are not supported
    pub insertable_columns: Option&lt;Vec&lt;String&gt;&gt;,
    /// The set of names of updateable columns, or null if updates are not supported
    pub updatable_columns: Option&lt;Vec&lt;String&gt;&gt;,
    /// Whether or not existing rows can be deleted from the collection
    pub deletable: bool,
    /// Any uniqueness constraints enforced on this collection
    pub uniqueness_constraints: BTreeMap&lt;String, UniquenessConstraint&gt;,
    /// Any foreign key constraints enforced on this collection
    pub foreign_keys: BTreeMap&lt;String, ForeignKeyConstraint&gt;,
}</code></pre>
<h2 id="collectioninsertschema"><a class="header" href="#collectioninsertschema"><code>CollectionInsertSchema</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct CollectionInsertSchema {
    /// The fields that will be found in the insert row data for the collection and the schema for each field
    pub fields: BTreeMap&lt;String, InsertFieldSchema&gt;,
    /// The name of a collection
    pub collection: String,
}</code></pre>
<h2 id="type"><a class="header" href="#type"><code>Type</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// Types track the valid representations of values as JSON
#[derive(
    Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(tag = &quot;type&quot;, rename_all = &quot;snake_case&quot;)]
pub enum Type {
    /// A named type
    Named {
        /// The name can refer to a primitive type or a scalar type
        name: String,
    },
    /// A nullable type
    Nullable {
        /// The type of the non-null inhabitants of this type
        underlying_type: Box&lt;Type&gt;,
    },
    /// An array type
    Array {
        /// The type of the elements of the array
        element_type: Box&lt;Type&gt;,
    },
}</code></pre>
<h2 id="unarycomparisonoperator"><a class="header" href="#unarycomparisonoperator"><code>UnaryComparisonOperator</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(
    Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize, JsonSchema,
)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum UnaryComparisonOperator {
    IsNull,
}</code></pre>
<h2 id="uniquenessconstraint"><a class="header" href="#uniquenessconstraint"><code>UniquenessConstraint</code></a></h2>
<pre><code class="language-rust no_run noplayground">#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UniquenessConstraint {
    /// A list of columns which this constraint requires to be unique
    pub unique_columns: Vec&lt;String&gt;,
}</code></pre>
<h2 id="updateoperatordefinition"><a class="header" href="#updateoperatordefinition"><code>UpdateOperatorDefinition</code></a></h2>
<pre><code class="language-rust no_run noplayground">/// The definition of an update operator on a scalar type
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, JsonSchema)]
pub struct UpdateOperatorDefinition {
    /// The type of the argument to this operator
    pub argument_type: Type,
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
